<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC0793 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.0793.xml'>
  <!ENTITY RFC1950 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1950.xml'>
  <!ENTITY RFC2617 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml'>
  <!ENTITY RFC4366 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4366.xml'>
  <!ENTITY RFC4559 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4559.xml'>
  <!ENTITY RFC6454 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6454.xml'>
  <!ENTITY RFC6455 PUBLIC '' 'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6455.xml'>
  ]>
<?xml-stylesheet type="text/xsl" href="lib/rfc2629.xslt"?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes"?>
<?rfc subcompact="no" ?>
<?rfc linkmailto="no" ?>
<?rfc editing="no" ?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<?rfc-ext include-index="no" ?>
<rfc ipr="trust200902" 
     category="std"
     docName="draft-mbelshe-httpbis-spdy-00"
     x:maturity-level="proposed"
     xmlns:x='http://purl.org/net/xml2rfc/ext'>
     <x:feedback template="mailto:spdy-dev@googlegroups.com?subject={docname},%20%22{section}%22&amp;body=&lt;{ref}&gt;:"/>
  <front>
    <title abbrev="SPDY">SPDY Protocol</title>
    <author initials="M." surname="Belshe" fullname="Mike Belshe">
      <organization>Twist</organization>
      <address>
        <email>mbelshe@chromium.org</email>
      </address>
    </author>
    <author initials="R." surname="Peon" fullname="Roberto Peon">
      <organization>Google, Inc</organization>
      <address>
        <email>fenix@google.com</email>
      </address>
    </author>
    <date month="August" year="2012" />
    <area>Applications</area>
    <keyword>HTTP</keyword>
    <abstract>
      <t>This document describes SPDY, a protocol designed for low-latency transport of content over the World Wide Web.  SPDY introduces two layers of protocol.  The lower layer is a general purpose framing layer which can be used atop a reliable transport (likely TCP) for multiplexed, prioritized, and compressed data communication of many concurrent streams.  The upper layer of the protocol provides HTTP-like semantics for compatibility with existing HTTP application servers.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Overview">
      <t>One of the bottlenecks of HTTP implementations is that HTTP relies on multiple connections for concurrency. This causes several problems, including additional round trips for connection setup, slow-start delays, and connection rationing by the client, where it tries to avoid opening too many connections to any single server.  HTTP pipelining helps some, but only achieves partial multiplexing.  In addition, pipelining has proven non-deployable in existing browsers due to intermediary interference.</t>

      <t>SPDY adds a framing layer for multiplexing multiple, concurrent streams across a single TCP connection (or any reliable transport stream).  The framing layer is optimized for HTTP-like request-response streams, such that applications which run over HTTP today can work over SPDY with little or no change on behalf of the web application writer.</t>

      <t>The SPDY connection offers four improvements over HTTP:
        <list>
          <t>Multiplexed requests: There is no limit to the number of requests that can be issued concurrently over a single SPDY connection.</t>
          <t>Prioritized requests: Clients can request certain resources to be delivered first.  This avoids the problem of congesting the network channel with non-critical resources when a high-priority request is pending.</t>
          <t>Compressed headers:  Clients today send a significant amount of redundant data in the form of HTTP headers.  Because a single web page may require 50 or 100 subrequests, this data is significant.</t>
          <t>Server pushed streams:  Server Push enables content to be pushed from servers to clients without a request.</t>
        </list>
      </t>

      <t>SPDY attempts to preserve the existing semantics of HTTP. All features such as cookies, ETags, Vary headers, Content-Encoding negotiations, etc work as they do with HTTP; SPDY only replaces the way the data is written to the network.</t>

      <section title="Document Organization">
        <t>
          The SPDY Specification is split into two parts: <xref target="FramingLayer">a
          framing layer</xref>, which multiplexes a single TCP connection into independent
          frames of various types; and <xref target="HTTPLayer">an HTTP layer</xref>, which specifies the mechanism
          for expressing HTTP interactions using the framing layer. While some of the
          framing layer concepts are isolated from HTTP, building a generic framing layer
          has not been a goal. The framing layer is tailored to the needs of the HTTP protocol and
          server push.
        </t>
      </section>
      <section title="Conventions and Terminology">
        <t>
          The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.
        </t>
        <t>
          All numeric values are in network byte order.  Values are unsigned unless otherwise
          indicated.  Literal values are provided in decimal or hexadecimal as appropriate.
          Hexadecimal literals are prefixed with <spanx style="verb">0x</spanx> to distinguish them
          from decimal literals.
        </t>
        <t>
          The following terms are used:
          <list style="hanging">
            <t hangText="client:">
              The endpoint initiating the SPDY connection.
            </t>
            <t hangText="connection:">
              A transport-level connection between two endpoints.
            </t>
            <t hangText="endpoint:">
              Either the client or server of the connection.
            </t>
            <t hangText="frame:">
              The smallest unit of communication within an SPDY connection, 
              consisting of a header and a variable-length sequence of bytes
              structured according to the frame type.
            </t>
            <t hangText="peer:">
              An endpoint.  When discussing a particular endpoint, "peer" refers to the endpoint
              that is remote to the primary subject of discussion.
            </t>
            <t hangText="receiver:">
              An endpoint that is receiving frames.
            </t>
            <t hangText="sender:">
              An endpoint that is transmitting frames.
            </t>
            <t hangText="server:">
              The endpoint which did not initiate the SPDY connection.
            </t>
            <t hangText="connection error:">
              An error on the SPDY connection.
            </t>
            <t hangText="stream:">
              A bi-directional flow of frames across a virtual channel within 
              the SPDY connection.
            </t>
            <t hangText="stream error:">
              An error on the individual SPDY stream.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="FramingLayer" title="SPDY Framing Layer">
      <section title="Connection">
        <t>The SPDY framing layer runs atop a reliable transport layer such as <xref target="RFC0793">TCP</xref>. The client is the TCP connection initiator. SPDY connections are persistent connections.</t>

        <t>For best performance, it is expected that non-battery operated clients will leave open connections until the user navigates away from all web pages referencing the connection, or until the server closes the connection. Servers are encouraged to leave connections open for as long as possible, but can terminate idle connections if necessary.  When either endpoint closes the transport-level connection, it MUST first send a <xref target="GOAWAY">GOAWAY</xref> frame so that the endpoints can reliably determine if requests finished before the close. It is expected that battery-operated clients may have more involved heuristics as to when a connection should be closed.</t>
      </section>

      <section anchor="ConnectionHeader" title="Connection Header">
        
        <t>Upon establishment of a TCP connection and determination 
          that SPDY will be used by both peers to communicate, each 
          endpoint MUST send a connection header as a final confirmation
          and to establish the default parameters for the SPDY connection.</t>

        <t>
          The client connection header is a sequence of 24 octets (in hex notation)
        </t>
       <figure><artwork type="inline">
464f4f202a20485454502f322e300d0a0d0a42410d0a0d0a</artwork></figure>
        <t>
          (the string <spanx style="verb">FOO * HTTP/2.0\r\n\r\nBA\r\n\r\n</spanx>) followed by a
          <xref target="SETTINGS">SETTINGS frame</xref>.  The client sends the client connection header
          immediately upon receipt of a 101 Switching Protocols response (indicating a successful
          upgrade), or after receiving a TLS Finished message from the server. If starting an
          SPDY connection with prior knowledge of server support for the protocol, the client
          connection header is sent upon connection establishment.
        </t>
        <t>
          <list>
            <t>
              The client connection header is selected so that a large proportion of HTTP/1.1 or
              HTTP/1.0 servers and intermediaries do not attempt to process further frames.  Note
              that this does not address the concerns raised in <xref target="TALKING"/>.
            </t>
          </list>
        </t>
        <t>
          The server connection header consists of just 
          a <xref target="SETTINGS">SETTINGS frame</xref> that MUST be the 
          first frame the server sends in the SPDY connection.
        </t>
        <t>
          To avoid unnecessary latency, clients are permitted to send 
          additional frames to the server immediately after sending the client 
          connection header, without waiting to receive the server connection header.
          It is important to note, however, that the server connection header 
          SETTINGS frame might include parameters that necessarily alter 
          how a client is expected to communicate with the server. Upon 
          receiving the SETTINGS frame, the client is expected to honor any 
          parameters established. 
        </t>
        <t>
          Clients and servers MUST terminate the TCP connection if either
          peer does not begin with a valid connection header.  A 
          <xref target="GOAWAY">GOAWAY frame</xref> MAY be omitted if it is 
          clear that the peer is not using SPDY.
        </t>
      </section>

      <section title="Framing">
        <t>Once the SPDY connection is established, clients and servers 
          can begin exchanging frames.</t>
        
        <section anchor="FrameHeader" title="Frame Header">
          <t>
            SPDY frames share a common base format consisting of 
            an 8-byte header followed by 0 to 65535 bytes of data.
          </t>
          <figure title="Frame Header">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Length (16)           |   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+-+-------------------------------------------------------------+
|                     Frame Data (0...)                       ...
+---------------------------------------------------------------+
</artwork>
          </figure>
          <t>
            The fields of the frame header are defined as:
            <list style="hanging">
              <t hangText="Length:">
                The length of the frame data expressed as an unsigned 16-bit
                integer. The 8 bytes of the frame header are not included
                in this value.
              </t>
              <t hangText="Type:">
                The 8-bit type of the frame.  The frame type determines how the remainder of the
                frame header and data are interpreted.  Implementations MUST ignore unsupported 
                and unrecognized frame types.
              </t>
              <t hangText="Flags:">
                An 8-bit field reserved for frame-type specific boolean flags.
                <vspace blankLines="1"/>
                The least significant bit (0x1) - the FINAL bit - is defined for all frame types as
                an indication that this frame is the last the endpoint will send for the identified
                stream.  Setting this flag causes the stream to enter the <xref
                target="StreamHalfClose">half-closed state</xref>.  Implementations MUST process the
                FINAL bit for all frames whose stream identifier field is not 0x0.  The FINAL bit
                MUST NOT be set on frames that use a stream identifier of 0.
                <vspace blankLines="1"/> 
                The remaining flags can be assigned semantics specific to the 
                indicated frame type. Flags that have no defined semantics for 
                a particular frame type MUST be ignored, and MUST be left 
                unset (0) when sending.
              </t>
              <t hangText="R:">
                A reserved 1-bit field.  The semantics of this bit are undefined
                and the bit MUST remain unset (0) when sending and MUST be ignored
                when receiving.
              </t>
              <t hangText="Stream Identifier:">
                A 31-bit stream identifier (see <xref target="StreamCreation"/>).  A value 0 is
                reserved for frames that are associated with the connection as a 
                whole as opposed to an individual stream.
              </t>
            </list>
          </t>
          <t>The structure and content of the remaining frame data is 
            dependent entirely on the frame type.</t>
        </section>

        <section anchor="FrameSize" title="Frame Size">
          
          <t>Implementations with limited resources might not be capable of 
            processing large frame sizes. Such implementations MAY choose
            to place additional limits on the maximum frame size. However,
            all implementations MUST be capable of receiving and processing
            frames containing at least 8192 octets of data.
            <cref>Ed. Question: Does this minimum include the 8-byte header 
              or just the frame data?</cref></t>

          <t>An implementation MUST terminate a stream immediately if it is
            unable to process a frame due it's size. This is done by sending 
            an <xref target="RST_STREAM">RST_STREAM frame</xref> containing 
            the FRAME_TOO_LARGE error code.
          </t>
          <t>
            <cref><eref target="https://github.com/http2/http2-spec/issues/28">Issue 28</eref>: Need
            a way to signal the maximum frame size; no way to RST_STREAM on non-stream-related
            frames.</cref>
          </t>
        </section>
      </section>

      <section title="Streams">
       <t>
          A "stream" is an independent, bi-directional sequence of frames 
          exchanged between the client and server within a SPDY connection.
          Streams have several important characteristics:
          <list style="symbols">
            <t>
              Streams can be established and used unilaterally or shared by 
              either the client or server.
            </t>
            <t>
              Streams can be rejected or cancelled by either endpoint.
            </t>
            <t>
              Multiple types of frames can be sent by either endpoint within 
              a single stream.
            </t>
            <t>
              The order in which frames are sent within a stream is 
              significant. Recipients are required to process frames 
              in the order they are received.
            </t>
            <t>
              Streams optionally carry a set of name-value header pairs
              that are expressed within the headers block of HEADERS+PRIORITY, 
              HEADERS, or PUSH_PROMISE frames.
            </t>
            <t>
              A single SPDY connection can contain multiple concurrently
              active streams, with either endpoint interleaving frames from 
              multiple streams.
            </t>
          </list>
        </t>

        <section anchor="StreamCreation" title="Stream Creation">

          <t>
            There is no coordination or shared action between the client and 
            server required to create a stream. Rather, new streams are 
            established by sending a frame whose stream identifier field 
            references a previously unused stream identifier.
          </t>

          <t>
            All streams are identified by an unsigned 31-bit integer.  Streams 
            initiated by a client use odd numbered stream identifiers; those 
            initiated by the server use even numbered stream identifiers.  
            A stream identifier of zero MUST NOT be used to establish a new
            stream.
          </t>
          
          <t>
            The identifier of a newly established stream MUST be numerically 
            greater than all previously established streams from that endpoint
            within the SPDY connection, unless the identifier has been reserved 
            using a <xref target="PUSH_PROMISE">PUSH_PROMISE</xref> frame.  
            An endpoint that receives an unexpected stream identifier MUST 
            respond with a <xref target="ConnectionErrorHandler">connection error</xref> of type 
            PROTOCOL_ERROR.
          </t>
          
          <t>
            A peer can limit the total number of concurrently active streams 
            using the SETTINGS_MAX_CONCURRENT_STREAMS parameters within a 
            SETTINGS frame. The maximum concurrent streams setting is specific 
            to each endpoint and applies only to the peer. That is, clients 
            specify the maximum number of concurrent streams the server can 
            initiate, and servers specify the maximum number of concurrent 
            streams the client can initiate. Peer endpoints MUST NOT 
            exceed this limit. All concurrently active
            streams initiated by an endpoint, including streams that are 
            <xref target="StreamHalfClose">half-open</xref> in any direction, 
            count toward that endpoint's limit.
          </t>
          
          <t>
            Stream identifiers cannot be reused within a connection.  Long-lived
            connections can cause an endpoint to exhaust the available range of stream
            identifiers. A client that is unable to establish a new stream identifier can
            establish a new connection for new streams.
          </t>

          <t>
            Either endpoint can request the early termination of an unwanted 
            stream by sending an <xref target="StreamErrorHandler">RST_STREAM
            frame</xref> with an error code of either REFUSED_STREAM (if no
            frames have been processed) or CANCEL (if at least one frame has
            been processed). Such termination might not take effect immediately
            as the peer might have sent additional frames on the stream prior 
            to receiving the termination request.
          </t>
          
        </section>

        <section anchor="StreamPriority" title="Stream priority">
          <t>
            The endpoint establishing a new stream can assign a priority for 
            the stream.  Priority is represented as an unsigned 31-bit integer.  
            0 represents the highest priority and 2<x:sup>31</x:sup>-1 represents
            the lowest priority.
          </t>
          
          <t>
            The purpose of this value is to allow the initiating
            endpoint to request that frames for the stream be processed with 
            higher priority relative to any other concurrently active 
            streams. That is, if an endpoint receives interleaved frames
            for multiple streams, the endpoint ought to make a best-effort
            attempt at processing frames for higher priority streams before 
            processing those for lower priority streams.
          </t>
          
          <t>
            Explicitly setting the priority for a stream does not 
            guarantee any particular processing order for the stream
            relative to any other stream. Nor is there is any mechanism 
            provided by which the initiator of a stream can force or require 
            a receiving endpoint to process frames from one stream before 
            processing frames from another.
          </t>
          
        </section>

        <section anchor="StreamHalfClose" title="Stream half-close">
          
          <t>
            When an endpoint sends a frame for a stream with the FINAL flag 
            set, the stream is considered to be half-closed for that endpoint.
            Subsequent frames MUST NOT be sent by that endpoint for the half
            closed stream for the remaining duration of the SPDY connection.
            When both endpoints have sent frames with the FINAL flag set, the
            stream is considered to be fully closed.
          </t>

          <t>
            If an endpoint receives additional frames for a stream that was 
            previously half-closed by the sending peer, the recipient MUST 
            respond with a <xref target="StreamErrorHandler">stream error</xref> 
            of type STREAM_CLOSED.
          </t>
          
          <t>
            An endpoint that has not yet half-closed a stream by sending the
            FINAL flag can continue sending frames on the stream.
          </t>
          
          <t>
            It is not necessary for an endpoint to half-close a stream 
            for which it has not sent any frames. This allows endpoints to
            use fully unidirectional streams that do not require explicit
            action or acknowledgement from the receiver.
          </t>  

        </section>

        <section anchor="StreamClose" title="Stream close">
          <t>
            Streams can be terminated in the following ways:
            <list style="hanging">
              <t hangText="Normal termination:">
                Normal stream termination occurs when both client and server have half-closed the
                stream by sending a frame containing a <xref target="FrameHeader">FINAL flag</xref>.
              </t>
              <t hangText="Half-close on unidirectional stream:">
                A stream that only has frames sent in one direction can be tentatively considered to
                be closed once a frame containing a FINAL flag is sent.  The active sender on the
                stream MUST be prepared to receive frames after closing the stream.
              </t>
              <t hangText="Abrupt termination:">
                Either peer can send a RST_STREAM control frame at any time to terminate an
                active stream. RST_STREAM contains an error code to indicate the reason for
                termination.  A RST_STREAM indicates that the sender will transmit no further data
                on the stream and that the receiver is advised to cease transmission on it.
                <vspace blankLines="1"/>
                The sender of a RST_STREAM frame MUST allow for frames that have already been sent
                by the peer prior to the RST_STREAM being processed.  If in-transit frames alter
                connection state, these frames cannot be safely discarded.  See <xref
                target="StreamErrorHandler">Stream Error Handling</xref> for more details.
              </t>
              <t hangText="TCP connection teardown:">
                If the TCP connection is torn down while un-closed streams
                exist, then the endpoint MUST assume that the stream was abnormally interrupted and
                may be incomplete.
              </t>
            </list>
          </t>
        </section>
      </section>

      <section title="Error Handling">
        <t>
          SPDY framing permits two classes of error: 
          <list style="symbols">
            <t>
              An error condition that renders the entire connection unusable is a connection error.
            </t>
            <t>
              An error in an individual stream is a stream error.
            </t>
          </list>
        </t>

        <section anchor="ConnectionErrorHandler" title="Connection Error Handling">
          <t>
            A connection error is any error which prevents further processing of the framing layer or
            which corrupts any connection state.
          </t>
          <t>
            An endpoint that encounters a connection error MUST first send a <xref
            target="GOAWAY">GOAWAY</xref> frame with the stream identifier of the last stream that
            it successfully received from its peer.  The GOAWAY frame includes an error code that
            indicates why the connection is terminating.  After sending the GOAWAY frame, the endpoint
            MUST close the TCP connection.
          </t>
          <t>
            It is possible that the GOAWAY will not be reliably received by the receiving endpoint.
            In the event of a connection error, GOAWAY only provides a best-effort attempt to
            communicate with the peer about why the connection is being terminated.
          </t>
          <t>
            An endpoint can end a connection at any time.  In particular, an endpoint MAY choose to
            treat a stream error as a connection error if the error is recurrent.  Endpoints SHOULD
            send a GOAWAY frame when ending a connection, as long as circumstances permit it.
          </t>
        </section>

        <section anchor="StreamErrorHandler" title="Stream Error Handling">
          <t>
            A stream error is an error related to a specific stream identifier that does not affect
            processing of other streams at the framing layer.
          </t>
          <t>
            An endpoint that detects a stream error sends a <xref
            target="RST_STREAM">RST_STREAM</xref> frame that contains the stream identifier of the
            stream where the error occurred.  The RST_STREAM frame includes an error code that
            indicates the type of error.
          </t>
          <t>
            A RST_STREAM is the last frame that an endpoint can send on a stream.  The peer that
            sends the RST_STREAM frame MUST be prepared to receive any frames that were sent or
            enqueued for sending by the remote peer.  These frames can be ignored, except where they
            modify connection state (such as the state maintained for <xref
            target="HeaderBlock">header compression</xref>).
          </t>
          <t>
            Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame for any stream. However, an endpoint
            MAY send additional RST_STREAM frames if it receives frames on a closed stream after
            more than a round trip time.  This behavior is permitted to deal with misbehaving
            implementations.
          </t>
          <t>
            An endpoint MUST NOT send a RST_STREAM in response to an RST_STREAM frame, to avoid looping. 
          </t>
        </section>

        <section anchor="ErrorCodes" title="Error Codes">
          <t>
            Error codes are 32-bit fields that are used in RST_STREAM and GOAWAY frames to convey
            the reasons for the stream or connection error.
          </t>

          <t>
            Error codes share a common code space.  Some error codes only apply to specific
            conditions and have no defined semantics in certain frame types.
          </t>

          <t>
            The following error codes are defined:
            <list style="hanging">
              <t hangText="NO_ERROR (0):">
                The associated condition is not as a result of an error.  For example, a GOAWAY
                might include this code to indicate graceful shutdown of a connection.
              </t>
              <t hangText="PROTOCOL_ERROR (1):">
                The endpoint detected an unspecific protocol error.  This error is for use when a more
                specific error code is not available.
              </t>
              <t hangText="INTERNAL_ERROR (2):">
                The endpoint encountered an unexpected internal error.
              </t>
              <t hangText="FLOW_CONTROL_ERROR (3):">
                The endpoint detected that its peer violated the flow control protocol.
              </t>
              <t hangText="INVALID_STREAM (4):">
                The endpoint received a frame for an inactive stream.
              </t>
              <t hangText="STREAM_CLOSED (5):">
                The endpoint received a frame after a stream was half-closed.
              </t>
              <t hangText="FRAME_TOO_LARGE (6):">
                The endpoint received a frame that was larger than the maximum size that it
                supports.
              </t>
              <t hangText="REFUSED_STREAM (7):">
                The endpoint is refusing the stream before processing its payload.
              </t>
              <t hangText="CANCEL (8):">
                Used by the creator of a stream to indicate that the stream is no longer needed.
              </t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="HeaderBlock" title="Name/Value Header Block">

        <t>A Name/Value Header Block augments the streams or group of streams identified by the <xref target="HEADERS_PRIORITY">HEADERS+PRIORITY</xref>, <xref target="HEADERS">HEADERS</xref>, or <xref target="PUSH_PROMISE">PUSH_PROMISE</xref> frame stream with additional metadata.
        </t>

        <t>
          At the group level, a map of token-index to key-pair is maintained for each defined group. There is no persistent mapping from stream-id to header-group, instead each HeaderBlock includes reference to the HeaderGroup that will be used in this particular set of metadata.
        </t>

        <t>The HeaderBlock compressor (described later) is subject to the following constraints:
          <list>
            <t>TotalHeaderStorageSize :  default(16k)</t>
            <t>MaxHeaderGroups: default(1)</t>
            <t>MaxValEntries: default(64)</t>
          </list>
        </t>

        <t> It is expected that either party will set these to larger values immediately upon connection establishment using the SETTINGS frame.</t>

        <t> A stream with a HeaderBlock which declares that it is using HeaderGroup 'G' would use the following algorithm to interpret its meta-data.</t>

        <figure>
          <artwork>
            def compute_headers(stream):
            headers = {}
            for index in stream_group[G]:
            headers[lru_lookup[index].key] = lru_lookup[index].val)
            for {key, value} in ephemereal_headers_from_HeaderBlock:
            headers[key] = value
            return headers
          </artwork>
        </figure>

        <t>A smart implementation will be able to interpret a headers frame without reconstructing the headers, and thus be able to represent and interpret headers with less memory and CPU.</t>

        <t>The Name/Value Header Block is found in the HEADERS+PRIORITY, HEADERS, 
          and PUSH_PROMISE control frames, and shares a common format:</t>
        <figure>
          <artwork>
            0        1        2          3..N       N+1..K
            +--------+--------+--------+=====+     +=====+
            | HG(8)  | next-lru-seq-num| Ops | ... | Ops |
            +--------+--------+--------+=====+     +=====+
          </artwork>
        </figure>

        <t>Ops are of the form:
          <figure>
            <artwork>
              +--------+--------+=========+
              | OpCode | NumOps | Op Args |
              +--------+--------+=========+
            </artwork>
          </figure>
        </t>

        <t>HG: (Header Group) An 8 bit unsigned integer specifying the header group for this set of headers.</t>
        <t>Ops: A number of operations. Operations will be detailed below.</t>

        <t>
          The Opcode field indicates the type of operation.
          <list>
            <t>0x0 (reserved) -- this is not used and is reserved in case a token-based delimiter is required in the future.</t>
            <t>0x1 (Toggle) indicates that the data which follows will be an lru-index. That lru-index, if present in the current header-group will be removed from the header group. If it is not present in the current header group, it will be added to the current header group. This opcode thus affects what parts of the data stored in the LRU are interpreted as being visible in the current set of headers for whatever frame includes the HeaderBlock</t>
            <t>0x1 (Clone) indicates that the data which follows will be a key-index and a string literal. The key-index is used to refer to a pre-existing key, and thus the operation results in the storing of the pre-existing key and the new value. The key-value will be appended to the LRU, and the index in the LRU added to the current header group.</t>
            <t>0x2 (KVSto) indicates that the data which follows will be two string literals. The first such string represents a new key to be stored, and the second such string represents a value. As with Clone, the key-value will be stored in the LRU with a new index, and that index will be added to the current header group.</t>
            <t>0x2 (Eref)  indicates that the data which follows will be two string literals. The first such string represents key, and the second string represents a value. Unlike KVSto, the Eref does not modify the compressor state-- it only specified a key-value which will be interpreted as being part of the meta-data for the frame which includes the HeaderBlock.</t>
          </list>
        </t>

        <t> String are always encoded as a single bit, followed by data. If that bit is '0', then what follows is 7-bit us-ascii, null-terminated. If that bit is '1', then it is huffman encoded using a canonical huffman-code and ends with an 'eof' character (which is not part of the string). If the last bit of the EOF is not immediately before the byte boundary, the remaining bits of that byte are padded with zero. Strings in a request are encoded with a different huffman-encoder than strings in a response, as the frequency of occurance in these differ by quite a bit.
          <figure>
            <artwork>
              A string is either:
              +-|============================|====================|--------+
              |1| huffman-encoded-characters | huffman-eof-symbol |pad-bits|
              +-|============================|====================|--------+

              or

              +-|-------+========+--------+
              |0|  7 bit-ascii   |00000000|
              +-|-------+========+--------+
            </artwork>
          </figure>
        </t>

        <t>
          The NumOps field encodes one minus the number of operations that follow. Since the field-width is 8 bits, a maximum of 256 ops can be represented. If more than 256 operations are required, simply repeat doing this until all operations have been encoded. It is expected that this will be extremely rare.
        </t>

        <t>
          Detail of an operation with an opcode of 0x1 (Toggle):

          <figure>
            <artwork>
              0        1
              +--------+--------+
              |00000001| NumOps |
              +--------+--------+


              repeated NumOps times
                ______/ \______
               /               \

              +--------+--------+
              | LRU idx(16)     |
              +--------+--------+
            </artwork>
          </figure>
        </t>

        <t>
          Detail of an operation with an opcode of 0x2 (Clone):

          <figure>
            <artwork>
              0        1
              +--------+--------+
              |00000010| NumOps |
              +--------+--------+


                 repeated NumOps times
                ___________/\___________
               /                        \

              +--------+--------+========+
              | Key idx(16)     | String |
              +--------+--------+========+
            </artwork>
          </figure>
        </t>

        <t>
          Detail of an operation with an opcode of 0x3 (KVSto):

          <figure>
            <artwork>
              0        1
              +--------+--------+
              |00000011| NumOps |
              +--------+--------+


              repeated NumOps times
                _______/\______
               /               \

              +========+========+
              | String | String |
              +========+========+
            </artwork>
          </figure>
        </t>

        <t>
          Detail of an operation with an opcode of 0x4 (Eref):

          <figure>
            <artwork>
              0        1
              +--------+--------+
              |00000100| NumOps |
              +--------+--------+


              repeated NumOps times
                _______/\______
               /               \

              +========+========+
              | String | String |
              +========+========+
            </artwork>
          </figure>
        </t>


        <t>Each header name must have at least one value.  Header names are encoded using the <xref target="ASCII">US-ASCII character set</xref> and must be all lower case.  The length of each name must be greater than zero.  A recipient of a zero-length name MUST issue a <xref target="StreamErrorHandler">stream error</xref> with the status code PROTOCOL_ERROR for the stream-id.</t>

        <t>Duplicate header names are allowed, but discouraged, except when encoding a cookie or set-cookie.</t>

        <section title="Compression" anchor="Compression">
          <t>The Name/Value Header Block is a section of the HEADERS+PRIORITY, HEADERS, and PUSH_PROMISE frames used to carry header meta-data.  This block is always compressed using zlib compression.  Within this specification, any reference to 'zlib' is referring to the <xref target="RFC1950">ZLIB Compressed Data Format Specification Version 3.3 as part of RFC1950.</xref></t>

          <t>For each HEADERS compression instance, the initial state is initialized using the following <xref target="UDELCOMPRESSION">dictionary</xref>:</t>

          <figure>
            <artwork>
              Request 1 (for index.html):
              HEADERS+PRIORITY 1, stream-group (G)=0
              Header-block:
              Store(0x1): level(C),index(0),k: ":method"
              Store(0x1): level(C),index(0),v: "GET"
              Store(0x1): level(C),index(1),k: ":version"
              Store(0x1): level(C),index(1),v: "HTTP/1.1"
              Store(0x1): level(C),index(2),k: "user-agent"
              Store(0x1): level(C),index(2),v: "blah blah browser version blah blah"
              Store(0x1): level(C),index(3),k: "accept-encoding"
              Store(0x1): level(C),index(3),v: "sdch, bzip, compress"
              Store(0x1): level(G),index(0),k: ":host"
              Store(0x1): level(G),index(0),v: "www.foo.com"
              Store(0x1): level(G),index(1),k: "cookie"
              Store(0x1): level(G),index(1),v: "SOMELONGSTRINGTHATISMOSTLYOPAQUE;BLAJHBLA"
              Store(0x1): level(G),index(2),k: ":path"
              Store(0x1): level(G),index(2),v: "/index.html"
              Store(0x1): level(G),index(3),k: "date"
              Store(0x1): level(G),index(3),v: "Wed Jul 18 11:50:43 2012"

              At this point the connection headers table looks like this:
              0: ":method", "GET"
              1: ":version", "HTTP/1.1"
              2: "user-agent", "blah blah browser version blah blah"
              3: "accept-encoding", "sdch, bzip, compress"

              The stream-group table for group zero looks like this:
              0: ":host", "www.foo.com"
              1: "cookie", "SOMELONGSTRINGHTATISMOSTLYOPAQUE;BLAJHBLA"
              2: ":path", "/index.html"
              3: "date", "Wed Jul 18 11:50:43 2012"

              Request 1 (on stream 1) would look like the following if forwarded on HTTP/1.1:
              GET /index.html HTTP/1.1
              host: www.foo.com
              date: Wed Jul 18 11:50:43 2012
              cookie: SOMELONGSTRINGTHATISMOSTLYOPAQUE;BLAJHBLA
              user-agent: blah blah browser version blah blah
              accept-encoding: sdch, bzip, compress


              Request 2 (for index.js):
              HEADERS+PRIORITY 3, stream-group (G)=0
              Header-block:
              Store(0x1): level(G),index(2),v: "/index.js"
              Store(0x1): level(G),index(3),v: "Wed Jul 18 11:50:44 2012"

              At this point the connection headers table is unchanged:
              0: ":method", "GET"
              1: ":version", "HTTP/1.1"
              2: "user-agent", "blah blah browser version blah blah"
              3: "accept-encoding", "sdch, bzip, compress"

              The stream-group table for group zero looks like this:
              0: ":host", "www.foo.com"
              1: "cookie", "SOMELONGSTRINGHTATISMOSTLYOPAQUE;BLAJHBLA"
              2: ":path", "/index.js"
              3: "date", "Wed Jul 18 11:50:44 2012"
              Both the path and the date have changed.

              Request 2 (on stream 3) would look like the following if forwarded on HTTP/1.1:
              GET /index.js HTTP/1.1
              host: www.foo.com
              date: Wed Jul 18 11:50:44 2012
              cookie: SOMELONGSTRINGTHATISMOSTLYOPAQUE;BLAJHBLA
              user-agent: blah blah browser version blah blah
              accept-encoding: sdch, bzip, compress


              Request 3 (for index.css):
              HEADERS+PRIORITY 5, stream-group (G)=0
              Header-block:
              Store(0x1): level(G),index(2),v: "/index.css"
              Store(0x1): level(G),index(3),v: "Wed Jul 18 11:50:44 PDT 2012"

              Connection level-headers are implied.
              Stream-group level headers are implied.

              For this example, using TaCo (truncate and concatenate) wasn't useful.
              If the user, however, changes the cookie on the next request...

              Request 3 (for somepage.html):
              HEADERS+PRIORITY 5, stream-group (G)=0
              Header-block:
              Store(0x1): level(G),index(2),v: "/somepage.html"
              TaCo(0x1): level(G),index(1),v,TruncTo(40),"FOOBLA"

              At this point the connection headers table remains unchanged.
              0: ":method", "GET"
              1: ":version", "HTTP/1.1"
              2: "user-agent", "blah blah browser version blah blah"
              3: "accept-encoding", "sdch, bzip, compress"

              The stream-group table for group zero looks like this:
              0: ":host", "www.foo.com"
              1: "cookie", "SOMELONGSTRINGHTATISMOSTLYOPAQUE;FOOBLA"
              2: ":path", "/somepate.html"
              Both the path and the date have changed.

              Request 3 (on stream 5) would look like the following if forwarded on HTTP/1.1:
              GET /somepage.html HTTP/1.1
              host: www.foo.com
              date: Wed Jul 18 11:50:44 2012
              cookie: SOMELONGSTRINGTHATISMOSTLYOPAQUE;FOOBLA
              user-agent: blah blah browser version blah blah
              accept-encoding: sdch, bzip, compress

            </artwork>
          </figure>
        </section>
      </section>

      <section title="Frame Types" anchor="frame-types">
        
        <t>
          This specification defines a number of frame types, 
          each identified by a unique 8-bit type code. Each frame
          type serves a distinct purpose either in the establishment and 
          management of the connection as a whole, or of individual streams.
        </t>
        
        <t>
          The transmission of specific frame types can alter the state of 
          a connection. If endpoints fail to maintain a synchronized view 
          of the connection state, successful communication within the connection 
          will no longer be possible. Therefore, it is important that endpoints 
          have a shared comprehension of how the state is affected by the use
          any given frame. Accordingly, while it is expected that new frame 
          types will be introduced by extensions to this protocol, only frames
          defined by this document are permitted to alter the connection state.
        </t>

        <section anchor="DataFrames" title="DATA Frames">
          
          <t>
            DATA frames (type=0x0) convey arbitrary, variable-length
            sequences of octets associated with a stream. One or more 
            DATA frames are used, for instance, to carry HTTP request
            or response payloads.
          </t>
          
          <t>
            The DATA frame defines the following flag:
            <list style="hanging">
              <t hangText="MSG_DONE (0x2):">
                Bit 2 being set signifies that this frame represents the last frame of a message.
                This is relevant for layering of message-based protocols on top of SPDY.
              </t>
            </list>
          </t>
          
          <t>
            DATA frames MUST be associated with a stream. If a DATA frame is 
            received whose stream identifier field is 0x0, the recipient MUST 
            respond with a <xref target="ConnectionErrorHandler">connection error</xref> 
            of type PROTOCOL_ERROR.
          </t>
          
        </section>

        <section anchor="HEADERS_PRIORITY" title="HEADERS+PRIORITY">
          <t>
            The HEADERS+PRIORITY frame (type=0x1) allows the sender to 
            set header fields and stream priority at the same time.
          </t>
          <figure title="HEADERS+PRIORITY Frame Payload">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                   Priority (31)                             |
+-+-------------------------------------------------------------+
|                    Header Block (*)                         ...
+---------------------------------------------------------------+
</artwork>
          </figure>

          <t>
            The HEADERS+PRIORITY frame is identical to the <xref target="HEADERS">HEADERS
            frame</xref>, preceded by a single reserved bit and a 31-bit priority; see
            <xref target="StreamPriority"/>.
          </t>
          
          <t>
            HEADERS+PRIORITY uses the same flags as the HEADERS frame, except that a
            HEADERS+PRIORITY frame with a CONTINUES bit MUST be followed by another HEADERS+PRIORITY
            frame.  See <xref target="HEADERS">HEADERS frame</xref> for any flags.
          </t>
          <t>
            HEADERS+PRIORITY frames MUST be associated with a stream. If a 
            HEADERS+PRIORITY frame is received whose stream 
            identifier field is 0x0, the recipient MUST respond with a 
            <xref target="ConnectionErrorHandler">connection error</xref> of type 
            PROTOCOL_ERROR.
          </t>
            
          <t>
            The HEADERS+PRIORITY frame modifies the connection state as 
            defined in <xref target="HeaderBlock" />.
          </t>
            
        </section>

        <section anchor="RST_STREAM" title="RST_STREAM">
          <t>
            The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.  When sent by
            the initiator of a stream, it indicates that they wish to cancel the stream.  When
            sent by the receiver of a stream, it indicates that either the 
            receiver is rejecting the stream, requesting that the stream be 
            cancelled or that an error condition has occurred. 
          </t>
          <figure title="RST_STREAM Frame Payload">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Error Code (32)                       |
+---------------------------------------------------------------+
</artwork>
          </figure>

          <t>
            The RST_STREAM frame contains a single unsigned, 
            32-bit integer identifying the <xref target="ErrorCodes">error code</xref>.  
            The error code indicates why the stream is being terminated.
          </t>
          
          <t>
            No type-flags are defined.
          </t>

          <t>
            The RST_STREAM frame fully terminates the referenced stream
            and causes it to enter the closed state. After receiving a 
            RST_STREAM on a stream, the receiver MUST NOT send additional 
            frames for that stream. However, after sending the RST_STREAM, 
            the sending endpoint MUST be prepared to receive and process 
            additional frames sent on the stream that might have been sent 
            by the peer prior to the arrival of the RST_STREAM.
          </t>

          <t>
            RST_STREAM frames MUST be associated with a stream. If a 
            RST_STREAM frame is received whose stream 
            identifier field is 0x0 the recipient MUST respond with a 
            <xref target="ConnectionErrorHandler">connection error</xref> of type 
            PROTOCOL_ERROR.
          </t>

        </section>

        <section anchor="SETTINGS" title="SETTINGS">
          <t>
            The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints
            communicate. The parameters are either constraints on peer behavior or preferences.
          </t>
          
          <t>
            SETTINGS frames MUST be sent at the start of a connection, and MAY 
            be sent at any other time by either endpoint over the lifetime 
            of the connection. 
          </t>
          
          <t>
            Implementations MUST support all of the settings defined by this 
            specification and MAY support additional settings defined by 
            extensions. Unsupported or unrecognized settings MUST be ignored.
            New settings MUST NOT be defined or implemented in a way that 
            requires endpoints to understand them in order to communicate
            successfully.
          </t>
                    
          <t>
            A SETTINGS frame is not required to include every defined 
            setting; senders can include only those parameters for which it 
            has accurate values and a need to convey. When multiple parameters 
            are sent, they SHOULD be sent in order of numerically lowest ID to 
            highest ID.  A single SETTINGS frame MUST NOT contain multiple values for the same ID.  If the
            receiver of a SETTINGS frame discovers multiple values for the same ID, it MUST ignore
            all values for that ID except the first one.
          </t>
          <t>
            Over the lifetime of a connection, an endpoint MAY send multiple SETTINGS frames
            containing previously unspecified parameters or new values for parameters whose values
            have already been established. Only the most recent value provided setting value
            applies.
          </t>
          <t>
            The SETTINGS frame defines the following flag:
            <list style="hanging">
              <t hangText="CLEAR_PERSISTED (0x2):">
                Bit 2 being set indicates a request to clear any previously persisted settings
                before processing the settings.  Clients MUST NOT set this flag.
              </t>
            </list>
          </t>
          <t>
            SETTINGS frames always apply to a connection, never a single stream.  
            The stream identifier for a settings frame MUST be zero. If an 
            endpoint receives a SETTINGS frame whose stream identifier field
            is anything other than 0x0, the endpoint MUST respond with a 
            <xref target="ConnectionErrorHandler">connection error</xref> of type
            PROTOCOL_ERROR.
          </t>

          <section title="Setting Format" anchor="SettingFormat">
            
            <t>
              The payload of a SETTINGS frame consists of zero or more settings. Each setting
              consists of an 8-bit flags field specifying per-item instructions, an unsigned 24-bit
              setting identifier, and an unsigned 32-bit value.
            </t>
            
            <figure title="Setting Format">
              <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|SettingFlags(8)|             Setting Identifier (24)           |
+---------------+-----------------------------------------------+
|                        Value (32)                             |
+---------------------------------------------------------------+
</artwork>
            </figure>
            
            <t>
              Two flags are defined for the 8-bit flags field:
              <list style="hanging">
                <t hangText="PERSIST_VALUE (0x1):">
                  Bit 1 (the least significant bit) being set indicates a request from the server
                  to the client to persist this setting.  A client MUST NOT set this flag.
                </t>
                <t hangText="PERSISTED (0x2):">
                  Bit 2 being set indicates that this setting is a persisted setting being
                  returned by the client to the server.  This also indicates that this setting is
                  not a client setting, but a value previously set by the server.  A server MUST
                  NOT set this flag.
                </t>
              </list>
            </t>
          </section>

          <section title="Setting Persistence">
            <t>
              <cref>Note that persistence of settings is under discussion in the WG and might be
              removed in a future version of this document.</cref>
            </t>
            
            <t>
              A server endpoint can request that configuration parameters 
              sent to a client in a SETTINGS frame are to be persisted by 
              the client across SPDY connections and returned to the server
              in any new SETTINGS frame the client sends to the server
              in the current connection or any future connections.
            </t>
            
            <t>
              Persistence is requested on a per-setting basis by setting the
              PERSIST_VALUE flag (0x1).
            </t>
            
            <t>
              Client endpoints are not permitted to make such requests. Servers
              MUST ignore any attempt by clients to request that a server 
              persist configuration parameters.
            </t>
            
            <t>
              Persistence of configuration parameters is done on a per-origin
              basis (see <xref target="RFC6454"/>). That is, when a client 
              establishes a connection with a server, and the server requests that
              the client maintain persistent settings, the client SHOULD return 
              the persisted settings on all future connections to the same origin,
              IP address and TCP port.
            </t>

            <t>
              Whenever the client sends a SETTINGS frame in the current connection,
              or establishes a new connection with the same origin, persisted 
              configuration parameters are sent with the PERSISTED
              flag (0x2) set for each persisted parameter.
            </t>
            
            <t>
              Persisted settings accumulate until the server requests that
              all previously persisted settings are to be cleared by setting 
              the CLEAR_PERSISTED (0x2) flag on the SETTINGS frame.
            </t>

            <t>
              For example, if the server sends IDs 1, 2, and 3 with the 
              FLAG_SETTINGS_PERSIST_VALUE in a first SETTINGS frame, and then 
              sends IDs 4 and 5 with the FLAG_SETTINGS_PERSIST_VALUE in a 
              subsequent SETTINGS frame, the client will return values for 
              all 5 settings (1, 2, 3, 4, and 5 in this example) to the server.
            </t>          
          </section>
          
          <section anchor="SettingValues" title="Defined Settings">
            <t>
              <list style="hanging">
                <t hangText="SETTINGS_UPLOAD_BANDWIDTH (1):">
                  indicates the sender's estimated upload bandwidth for this connection. The value 
                  is an the integral number of kilobytes per
                  second that the sender predicts as an expected maximum upload channel capacity.
                </t>
                <t hangText="SETTINGS_DOWNLOAD_BANDWIDTH (2):">
                  indicates the sender's estimated download bandwidth for this connection. The value 
                  is an integral number of kilobytes per
                  second that the sender predicts as an expected maximum download channel capacity.
                </t>
                <t hangText="SETTINGS_ROUND_TRIP_TIME (3):">
                  indicates the sender's estimated round-trip-time for this connection. The round
                  trip time is defined as the minimum amount of time to send a control frame from
                  this client to the remote and receive a response. The value is represented in
                  milliseconds.
                </t>
                <t hangText="SETTINGS_MAX_CONCURRENT_STREAMS (4):">
                  indicates the maximum number of concurrent streams that the sender will allow. 
                  This limit is directional: it applies to the number
                  of streams that the sender permits the receiver to create. By default there is no
                  limit.  It is recommended that this value be no smaller than 100,
                  so as to not unnecessarily limit parallelism.
                </t>
                <t hangText="SETTINGS_CURRENT_CWND (5):">
                  indicates the sender's current TCP CWND value.
                </t>
                <t hangText="SETTINGS_DOWNLOAD_RETRANS_RATE (6):">
                  indicates the sender's retransmission rate (bytes retransmitted / total bytes transmitted).
                </t>
                <t hangText="SETTINGS_INITIAL_WINDOW_SIZE (7):">
                  indicates the sender's initial stream window size (in bytes) for new streams.
                </t>
                <t hangText="SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE (8):">
                  indicates the sender's (which should be the server) size of the client certificate vector.
                </t>
                <t hangText="SETTINGS_SUPPORTING_SCHEMES (9):">
                  indicates the sender's supported overlayering protocol schemes. The corresponding value must be a 32-bit value, and which contains flags as follows:
                  <list>
                    <t>bit 0: http</t>
                    <t>bit 1: https</t>
                    <t>bit 2: ws</t>
                    <t>bit 3: wss</t>
                  </list>
                </t>
                <t hangText="SETTINGS_FLOW_CONTROL_OPTIONS (10):">
                  indicates that streams directed to the sender will not
                  be subject to flow control.  The least significant bit (0x1) is set to indicate
                  that new streams are not flow controlled.  All other bits are reserved.
                  This setting applies to all streams, including existing streams.
                  These bits cannot be cleared once set, see <xref target="EndFlowControl"/>.
                </t>
              </list>
            </t>
          </section>
        </section>

        <section anchor="PUSH_PROMISE" title="PUSH_PROMISE">

          <t>
            The PUSH_PROMISE frame (type=0x5) is used to notify the peer 
            endpoint in advance of streams the sender intends to initiate.
            The PUSH_PROMISE frame includes the unsigned 31-bit identifier
            of the stream the endpoint plans to create along with a minimal
            set of headers that provide additional context for the stream.
            <xref target="PushResources"/> contains a thorough description
            of the use of PUSH_PROMISE frames.
          </t>

          <figure title="PUSH_PROMISE Payload Format">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                Promised-Stream-ID (31)                      |
+-+-------------------------------------------------------------+
|                    Header Block (*)                         ...
+---------------------------------------------------------------+
</artwork>
          </figure>
          
          <t>
            The payload of a PUSH_PROMISE includes a "Promised-Stream-ID".  This 
            unsigned 31-bit integer identifies the stream the endpoint
            intends to start sending frames for.  The promised stream
            identifier MUST be a valid choice for the next stream sent by the sender (see <xref
            target="StreamCreation">new stream identifier</xref>).
          </t>

          <t>
            PUSH_PROMISE frames MUST be associated with an existing stream. If 
            the stream identifier field specifies the value 0x0, a recipient
            MUST respond with a <xref target="ConnectionErrorHandler">connection 
            error</xref> of type PROTOCOL_ERROR.
          </t>
          
          <t>
            The state of promised streams is bound to the state of the 
            original associated stream on which the PUSH_PROMISE frame
            were sent. If the originating stream state changes to 
            fully closed, all associated promised streams fully close as well. 
            <cref>Ed. Note: We need clarification on this point. How synchronized
              are the lifecycles of streams and associated promised streams?</cref>
          </t>
          
          <t>
            PUSH_PROMISE uses the same flags as the HEADERS frame, except that a PUSH_PROMISE frame
            with a CONTINUES bit MUST be followed by another PUSH_PROMISE frame.  See <xref
            target="HEADERS">HEADERS frame</xref> for any flags.
          </t>

          <t>
            Promised streams are not required to be used in order promised.
            The PUSH_PROMISE only reserves stream identifiers for later use.
          </t>
          
          <t>
            Recipients of PUSH_PROMISE frames can choose to reject promised
            streams by returning a RST_STREAM referencing the promised stream
            identifier back to the sender of the PUSH_PROMISE.
          </t>
          
          <t>
            The PUSH_PROMISE frame modifies the connection state as 
            defined in <xref target="HeaderBlock" />.
          </t>
            
        </section>

        <section anchor="PING" title="PING">
          <t>
            The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the
            sender, as well as determining whether an idle connection is still functional.  
            PING frames can be sent from any endpoint.
          </t>
          
          <t>
            PING frames consist of an arbitrary, variable-length sequence of 
            octets. Receivers of a PING send a response PING frame with the PONG
            flag set and precisely the same sequence of octets back to the 
            sender as soon as possible.
          </t>
          
          <t>
            Processing of PING frames SHOULD be performed with the highest
            priority if there are additional frames waiting to be processed.
          </t>   
          
          <t>
            The PING frame defines one type-specific flag:
            <list style="hanging">
              <t hangText="PONG (0x2):">
                Bit 2 being set indicates that this PING frame is a PING response.  An endpoint MUST
                set this flag in PING responses.  An endpoint MUST NOT respond to PING frames
                containing this flag.
              </t>
            </list>
          </t>
          <t>
            PING frames are not associated with any individual stream. If a 
            PING frame is received with a stream identifier field value other
            than 0x0, the recipient MUST respond with a 
            <xref target="ConnectionErrorHandler">connection error</xref> of type 
            PROTOCOL_ERROR.
          </t>

        </section>

        <section anchor="GOAWAY" title="GOAWAY">
          <t>
            The GOAWAY frame (type=0x7) informs the remote peer to stop creating
            streams on this connection.  It can be sent from the client or the server. Once sent, the
            sender will ignore frames sent on new streams for the remainder of the
            connection. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection,
            although a new connection can be established for new streams.  The purpose of this frame
            is to allow an endpoint to gracefully stop accepting new streams (perhaps for a reboot
            or maintenance), while still finishing processing of previously established streams.
          </t>
          <t>
            There is an inherent race condition between an endpoint starting new streams and the
            remote sending a GOAWAY frame.  To deal with this case, the GOAWAY contains the stream
            identifier of the last stream which was processed on the sending endpoint in this
            connection.  If the receiver of the GOAWAY used streams that are newer than the indicated
            stream identifier, they were not processed by the sender and the receiver may treat the
            streams as though they had never been created at all (hence the receiver may want to
            re-create the streams later on a new connection).
          </t>
          <t>
            Endpoints should always send a GOAWAY frame before closing a connection so that the
            remote can know whether a stream has been partially processed or not.  (For example, if
            an HTTP client sends a POST at the same time that a server closes a connection, the
            client cannot know if the server started to process that POST request if the server does
            not send a GOAWAY frame to indicate where it stopped working).
          </t>

          <t>
            After sending a GOAWAY frame, the sender can ignore frames for new streams.
          </t>
          <t>
            <cref>Issue: connection state that is established by those "ignored" frames cannot be
            ignored without the state in the two peers becoming unsynchronized.</cref>
          </t>

          <figure title="GOAWAY Payload Format">
            <artwork type="inline">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|X|                  Last-Stream-ID (31)                        |
+-+-------------------------------------------------------------+
|                      Error Code (32)                          |
+---------------------------------------------------------------+
</artwork>
          </figure>
          <t>
            The GOAWAY frame does not define any type-specific flags.
          </t>
          <t>
            The GOAWAY frame applies to the connection, not a specific stream.  The stream identifier
            MUST be zero.
          </t>
         <t>
            The last stream identifier in the GOAWAY frame contains the highest numbered stream
            identifier for which the sender of the GOAWAY frame has received frames on and might
            have taken some action on.  All streams up to and including the identified stream might
            have been processed in some way.  The last stream identifier is set to 0 if no streams
            were processed.
            <list>
              <t>
                Note: In this case, "processed" means that some data from the stream was passed to
                some higher layer of software that might have taken some action as a result.
              </t>
            </list>
          </t>
          <t>
            On streams with lower or equal numbered identifiers that do not close completely prior
            to the connection being closed, re-attempting requests, transactions, or any protocol
            activity is not possible (with the exception of idempotent actions like HTTP GET, PUT,
            or DELETE).  Any protocol activity that uses higher numbered streams can be safely
            retried using a new connection.
          </t>
          <t>
            Activity on streams numbered lower or equal to the last stream identifier might still complete
            successfully.  The sender of a GOAWAY frame gracefully shut down a connection by sending
            a GOAWAY frame, maintaining the connection in an open state until all in-progress
            streams complete.
          </t>
          <t>
            The last stream ID MUST be 0 if no streams were acted upon.
          </t>
          <t>
            The GOAWAY frame also contains a 32-bit <xref target="ErrorCodes">error code</xref> that
            contains the reason for closing the connection.
          </t>
        </section>

        <section anchor="HEADERS" title="HEADERS">
          <t>
            The HEADERS frame (type=0x8) provides header fields for a stream. 
            Any number of HEADERS frames can may be sent on an existing stream 
            at any time.
          </t>
          <t>
            Additional type-specific flags for the HEADERS frame are:
            <list style="hanging">
              <t hangText="CONTINUES (0x2):">
                The CONTINUES bit indicates that this frame does not contain the entire payload
                necessary to provide a complete set of headers.
                <vspace blankLines="1"/>
                The payload for a complete set of headers is provided by a sequence of HEADERS
                frames, terminated by a HEADERS frame without the CONTINUES bit.  Once the sequence
                terminates, the payload of all HEADERS frames are concatenated and interpreted as a
                single block.
                <vspace blankLines="1"/>
                A HEADERS frame that includes a CONTINUES bit MUST be followed by a HEADERS frame
                for the same stream.  A receiver MUST treat the receipt of any other type of frame
                or a frame on a different stream as a <xref
                target="ConnectionErrorHandler">connection error</xref> of type PROTOCOL_ERROR.
              </t>
            </list>

          </t>
          <t>
            The payload of a HEADERS frame contains a <xref target="HeaderBlock">Headers Block</xref>.
          </t>
          <t>
            The HEADERS frame is associated with an existing stream. If 
            a HEADERS frame is received with a stream identifier of 0x0, 
            the recipient MUST respond with a
            <xref target="StreamErrorHandler">stream error</xref> of type
            PROTOCOL_ERROR.
          </t>
          <t>
            The HEADERS frame changes the connection state as defined in
            <xref target="HeaderBlock" />.
          </t>
        </section>

        <section anchor="WINDOW_UPDATE" title="WINDOW_UPDATE">
          <t>
            The WINDOW_UPDATE frame (type=0x9) is used to implement flow control.
          </t>
          <t>
            Flow control operates at two levels: on each individual stream and on the
            entire connection.
          </t>
          <t>
            Both types of flow control are hop by hop; that is, only between the two endpoints. 
            Intermediaries do not forward WINDOW_UPDATE frames between
            dependent connections.  However, throttling of data transfer by any receiver can
            indirectly cause the propagation of flow control information toward the original
            sender.
          </t>
          <t>
            Flow control only applies to frames that are identified as being subject to flow
            control. Of the frame types defined in this document, this includes only DATA frame.
            Frames that are exempt from flow control MUST be accepted and processed, unless the
            receiver is unable to assign resources to handling the frame.  A receiver MAY respond
            with a <xref target="StreamErrorHandler">stream error</xref> or <xref
            target="ConnectionErrorHandler">connection error</xref> of type FLOW_CONTROL_ERROR if it
            is unable accept a frame.
          </t>
          <t>
            The following additional flags are defined for the WINDOW_UPDATE frame:
            <list style="hanging">
              <t hangText="END_FLOW_CONTROL (0x2):">
                Bit 2 being set indicates that flow control for the identified stream or connection has been
                ended; subsequent frames do not need to be flow controlled.
              </t>
            </list>
        </t>
          <t>
             The WINDOW_UPDATE frame can be specific to a stream or to the entire connection. 
             In the former case, the frame's stream identifier indicates the affected stream;
             in the latter, the value "0" indicates that the entire connection is the subject of 
             the frame.
          </t>
          <t>
            The payload of a WINDOW_UPDATE frame is a 32-bit value indicating the
            additional number of bytes that the sender can transmit in addition to the existing flow
            control window.  The legal range for this field is 1 to 2<x:sup>31</x:sup> - 1
            (0x7fffffff) bytes; the most significant bit of this value is reserved.
          </t>

          <section title="The Flow Control Window">
            <t>
              Flow control in SPDY is implemented using a window kept by each sender on every
              stream. The flow control window is a simple integer value that indicates how many
              bytes of data the sender is permitted to transmit; as such, its size is a
              measure of the buffering capability of the receiver.
            </t>
            <t>
              Two flow control windows are applicable; the stream flow
              control window and the connection flow control window.  The sender MUST NOT send a flow
              controlled frame with a length that exceeds the space available in either of the flow
              control windows advertised by the receiver.  Frames with zero length with the FINAL
              flag set (for example, an empty data frame) MAY be sent if there is no available space
              in either flow control window.
            </t>
            <t>
              For flow control calculations, the 8 byte frame header is not counted.
            </t>
            <t>
              After sending a flow controlled frame, the sender reduces the space available in both
              windows by the length of the transmitted frame.
            </t>
            <t>
              The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up
              space in flow control windows.  Separate WINDOW_UPDATE frames are sent for the
              stream and connection level flow control windows.
            </t>
            <t>
              A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the
              amount specified in the frame.
            </t>
            <t>
              A sender MUST NOT allow a flow control window to exceed 2<x:sup>31</x:sup> - 1 bytes.
              If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this
              maximum it MUST terminate either the stream or the connection, as appropriate.  For
              streams, the sender sends a RST_STREAM with the error code of FLOW_CONTROL_ERROR code;
              for the connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code.
            </t>
            <t>
              Flow controlled frames from the sender and WINDOW_UPDATE frames from the receiver are
              completely asynchronous with respect to each other. This property allows a receiver to
              aggressively update the window size kept by the sender to prevent streams from
              stalling.
            </t>
          </section>

          <section title="Initial Flow Control Window Size">
            <t>
              When a SPDY connection is first established, new streams are created with an
              initial flow control window size of 65535 bytes. The connection flow control window is
              65536 bytes.  Both endpoints can adjust the initial window size for new streams by
              including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame that forms
              part of the connection header.
            </t>
            <t>
              Prior to receiving a SETTINGS frame that sets a value for
              SETTINGS_INITIAL_WINDOW_SIZE, a client can only use the default initial window size
              when sending flow controlled frames.  Similarly, the connection flow control window is
              set to the default initial window size until a WINDOW_UPDATE frame is received.
            </t>
            <t>
              A SETTINGS frame can alter the initial flow control window size for all current
              streams. When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST
              adjust the size of all flow control windows that it maintains by the difference
              between the new value and the old value.
            </t>
            <t>
              A change to SETTINGS_INITIAL_WINDOW_SIZE could cause the available space in a flow
              control window to become negative.  A sender MUST track the negative flow control
              window, and MUST NOT send new flow controlled frames until it receives WINDOW_UPDATE
              frames that cause the flow control window to become positive.
            </t>
            <t>
              For example, if the server sets the initial window size to be 16KB, and the client
              sends 64KB immediately on connection establishment, the client will recalculate the
              available flow control window to be -48KB on receipt of the SETTINGS frame.  The
              client retains a negative flow control window until WINDOW_UPDATE frames restore the
              window to being positive, after which the client can resume sending.
            </t>
          </section>

          <section title="Reducing the Stream Window Size">
            <t>
              A receiver that wishes to use a smaller flow control window than the current size
              can send a new SETTINGS frame.  However, the receiver MUST be prepared to receive data
              that exceeds this window size, since the sender might send data that exceeds the lower
              limit prior to processing the SETTINGS frame.
            </t>
            <t>
              A receiver has two options for handling streams that exceed flow control limits:
              <list style="numbers">
                <t>
                  The receiver can immediately send RST_STREAM with FLOW_CONTROL_ERROR error code
                  for the affected streams.
                </t>
                <t>
                  The receiver can accept the streams and tolerate the resulting head of line
                  blocking, sending WINDOW_UPDATE frames as it consumes data.
                </t>
              </list>
              If a receiver decides to accept streams, both sides MUST recompute the available flow
              control window based on the initial window size sent in the SETTINGS. 
            </t>
          </section>

          <section anchor="EndFlowControl" title="Ending Flow Control">
            <t>
              After a receiver reads in a frame that marks the end of a stream (for example, a data
              stream with a FINAL flag set), it MUST cease transmission of WINDOW_UPDATE frames for
              that stream. A sender is not obligated to maintain the available flow control window
              for streams that it is no longer sending on.
            </t>
            <t>
              Flow control can be disabled for all streams or the connection using the
              SETTINGS_FLOW_CONTROL_OPTIONS setting.  An implementation that does not wish to
              perform flow control can use this in the initial SETTINGS exchange.
            </t>
            <t>
              Flow control can be disabled for an individual stream or the overall connection by
              sending a WINDOW_UPDATE with the END_FLOW_CONTROL flag set.  The payload of a
              WINDOW_UPDATE frame that has the END_FLOW_CONTROL flag set is ignored.
            </t>
            <t>
              Flow control cannot be enabled again once disabled.  Any attempt to re-enable flow
              control - by sending a WINDOW_UPDATE or by clearing the bits on the
              SETTINGS_FLOW_CONTROL_OPTIONS setting - MUST be rejected with a FLOW_CONTROL_ERROR
              error code.
            </t>
          </section>
        </section>

        <section anchor="CREDENTIAL" title="CREDENTIAL">
          <t>The CREDENTIAL control frame is used by the client to send additional client certificates to the server.  A SPDY client may decide to send requests for resources from different origins on the same SPDY connection if it decides that that server handles both origins.  For example if the IP address associated with both hostnames matches and the SSL server certificate presented in the initial handshake is valid for both hostnames.  However, because the SSL connection can contain at most one client certificate, the client needs a mechanism to send additional client certificates to the server.</t>

          <t>The server is required to maintain a vector of client certificates associated with a SPDY connection.  When the client needs to send a client certificate to the server, it will send a CREDENTIAL frame that specifies the index of the slot in which to store the certificate as well as proof that the client posesses the corresponding private key.  The initial size of this vector must be 8.  If the client provides a client certificate during the first TLS handshake, the contents of this certificate must be copied into the first slot (index 1) in the CREDENTIAL vector, though it may be overwritten by subsequent CREDENTIAL frames.  The server must exclusively use the CREDENTIAL vector when evaluating the client certificates associated with an origin.  The server may change the size of this vector by sending a SETTINGS frame with the setting SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE value specified.  In the event that the new size is smaller than the current size, truncation occurs preserving lower-index slots as possible.</t>  

          <t>TLS renegotiation with client authentication is incompatible with SPDY given the multiplexed nature of SPDY.  Specifically, imagine that the client has 2 requests outstanding to the server for two different pages (in different tabs).  When the renegotiation + client certificate request comes in, the browser is unable to determine which resource triggered the client certificate request, in order to prompt the user accordingly.</t>

          <figure>
            <artwork>
0        1        2        3        4         5        6        7
+--------+--------+--------+--------+-|-------+--------+--------+--------+
| Length(16)      |    0xa |Flags(8)|X|               0x0                | -&gt;
+--------+--------+--------+--------+-|-------+--------+--------+--------+

8        9        10       11        12
+--------+--------+--------+--------+========+
| Slot(16)        |Proof Length(16) | Proof  | -&gt;
+--------+--------+--------+--------+========+

/--Repeated to frame end--\
+--------+--------+========+
| Cert Length(16) | Cert   |
+--------+--------+========+
            </artwork>
          </figure>

          <t>Slot: The index in the server's client certificate vector where this certificate should be stored.  If there is already a certificate stored at this index, it will be overwritten.  The index is one based, not zero based; zero is an invalid slot index.</t>
          <t>Proof: Cryptographic proof that the client has possession of the private key associated with the certificate.  The format is a TLS digitally-signed element (http://tools.ietf.org/html/rfc5246#section-4.7).  The signature algorithm must be the same as that used in the CertificateVerify message.  However, since the MD5+SHA1 signature type used in TLS 1.0 connections can not be correctly encoded in a digitally-signed element, SHA1 must be used when MD5+SHA1 was used in the SSL connection.  The signature is calculated over a 32 byte TLS extractor value (http://tools.ietf.org/html/rfc5705) with a label of "EXPORTER SPDY certificate proof" using the empty string as context. ForRSA certificates the signature would be a PKCS#1 v1.5 signature. For ECDSA, it would be an ECDSA-Sig-Value (http://tools.ietf.org/html/rfc5480#appendix-A).  For a 1024-bit RSA key, the CREDENTIAL message would be ~500 bytes.</t>
          <t>Certificate: The certificate chain, starting with the leaf certificate.  Each certificate must be encoded as a 32 bit length, followed by a DER encoded certificate.  The certificate must be of the same type (RSA, ECDSA, etc) as the client certificate associated with the SSL connection.</t>
          <t>If the server receives a request for a resource with unacceptable credential (either missing or invalid), it must reply with a RST_STREAM frame with the status code INVALID_CREDENTIALS. Upon receipt of a RST_STREAM frame with INVALID_CREDENTIALS, the client should initiate a new stream directly to the requested origin and resend the request.  Note, SPDY does not allow the server to request different client authentication for different resources in the same origin.</t>
          <t>If the server receives an invalid CREDENTIAL frame, it MUST respond with a GOAWAY frame and shutdown the connection.  </t>
        </section>
      </section>
    </section>

    <section anchor="HTTPLayer" title="HTTP Message Exchanges">
      <t>
        SPDY is intended to be as compatible as possible with current web-based
        applications. This means that, from the perspective of the server business logic or
        application API, the features of HTTP are unchanged. To achieve this, all of the application
        request and response header semantics are preserved, although the syntax of conveying those
        semantics has changed.  Thus, the rules from HTTP/1.1 (<xref target="HTTP-p1"/>, <xref
        target="HTTP-p2"/>, <xref target="HTTP-p4"/>, <xref target="HTTP-p5"/>, <xref
        target="HTTP-p6"/>, and <xref target="HTTP-p7"/>) apply with the changes in the sections
        below.
      </t>

      <section title="Connection Management">
        <t>
          Clients SHOULD NOT open more than one SPDY connection to a given origin
          (<xref target="RFC6454"/>) concurrently.
        </t>
        <t>
          Note that it is possible for one SPDY connection to be finishing (e.g. a GOAWAY frame
          has been sent, but not all streams have finished), while another SPDY connection is
          starting.
        </t>
      </section>

      <section title="HTTP Request/Response">

        <section title="HTTP Header Fields and SPDY Headers">
          <t>
            At the application level, HTTP uses name-value pairs in its header fields.  Because
            SPDY merges the existing HTTP header fields with SPDY headers, there is a
            possibility that some HTTP applications already use a particular header field name.  To
            avoid any conflicts, all header fields introduced for layering HTTP over SPDY are
            prefixed with ":".  ":" is not a valid sequence in HTTP/1.* header field naming,
            preventing any possible conflict.
          </t>
        </section>

        <section anchor="HttpRequest" title="Request">
          <t>
            The client initiates a request by sending a HEADERS+PRIORITY frame.  Requests that do
            not contain a body MUST set the FINAL flag, indicating that the client intends to send
            no further data on this stream, unless the server intends to push resources (see <xref
            target="PushResources"/>).  HEADERS+PRIORITY frame does not contain the FINAL flag for
            requests that contain a body.  The body of a request follows as a series of DATA
            frames. The last DATA frame sets the FINAL flag to indicate the end of the body.
          </t>

          <t>
            The header fields included in the HEADERS+PRIORITY frame contain 
            all of the HTTP header fields associated with an HTTP request.
            The definitions of these headers are largely unchanged relative 
            to HTTP/1.1, with a few notable exceptions:
            <list style="symbols">
              <t>The HTTP/1.1 request-line has been split into two separate
                header fields named :method and :path, whose values 
                specify the HTTP method for the request and the request-target,
                respectively. The HTTP-version component of the request-line
                is removed entirely from the headers.</t>
              <t>The host and optional port portions of the request URI 
                (see <xref target="RFC3986"/>, Section 3.2), is specified
                using the new :host header field. <cref>Ed. Note: it 
                needs to be clarified whether or not this replaces the
                existing HTTP/1.1 Host header.</cref></t>
              <t>A new :scheme header field has been added to specify the 
                scheme portion of the request-target (e.g. "https")</t>
              <t>All header field names MUST be lowercased, and the 
                definitions of all header field names defined by 
                HTTP/1.1 are updated to be all lowercase.</t>
              <t>The Connection, Host, Keep-Alive, Proxy-Connection, and 
                Transfer-Encoding header fields are no longer valid and 
                MUST NOT be sent.</t>
            </list>
          </t>
            
          <t>All HTTP Requests MUST include the ":method", ":path", ":host",
            and ":scheme" header fields.</t>
                        
          <t>Header fields whose names begin with ":" (whether defined in this 
            document or future extensions to this document) MUST appear before 
            any other header fields.</t>

          <t>
            If a client sends a HEADERS+PRIORITY frame that omits a mandatory 
            header, the server MUST reply with a HTTP 400 Bad Request reply.  
            <cref>Ed: why PROTOCOL_ERROR on missing ":status" in the response, 
              but HTTP 400 here?</cref>
          </t>

          <t>
             If a server receives a request where the sum of the data frame payload lengths does
             not equal the size of the Content-Length header field, the server MUST return a 400
             (Bad Request) error.
          </t>
          
          <t>
             Although POSTs are inherently chunked, POST requests SHOULD also be accompanied by a
             Content-Length header field.  First, it informs the server of how much data to
             expect, which the server can use to track overall progress and provide appropriate
             user feedback.  More importantly, some HTTP server implementations fail to correctly
             process requests that omit the Content-Length header field.  Many existing clients
             send a Content-Length header field, and some server implementations have come to
             depend upon its presence.
          </t>

          <t>
            A client provides priority in requests as a hint to the server.  A server SHOULD attempt
            to provide responses to higher priority requests before lower priority requests.  A
            server could send lower priority responses during periods that higher priority responses
            are unavailable to ensure better utilization of a connection.
          </t>
          <t>
            If the server receives a data frame prior to a HEADERS+PRIORITY frame the server MUST
            treat this as a <xref target="StreamErrorHandler">stream error</xref> of type
            PROTOCOL_ERROR.
          </t>
        </section>

        <section anchor="HttpResponse" title="Response">
          <t>
            The server responds to a client request using the same stream identifier that was used
            by the request.  An HTTP response begins with a HEADERS frame. An HTTP response body
            consists of a series of DATA frames.  The last data frame contains a FINAL flag to
            indicate the end of the response.  A response that contains no body (such as a 204 or
            304 response) consists only of a HEADERS frame that contains the FINAL flag to indicate
            no further data will be sent on the stream.
          </t>

          <t>
            <list>
              <t>
                The response status line is unfolded into name-value pairs like other HTTP header
                fields and must be present:
                <list style="hanging">
                  <t hangText="&quot;:status&quot;:">
                    The HTTP response status code (e.g. "200" or "200 OK")
                  </t>
                </list>
              </t>
              <t>
                All header field names starting with ":" (whether defined in this document or future
                extensions to this document) MUST appear before any other header fields.
              </t>
              <t>
                All header field names MUST be all lowercase.
              </t>
              <t>
                The Connection, Keep-Alive, Proxy-Connection, and Transfer-Encoding header fields
                are not valid and MUST NOT be sent.
              </t>
              <t>
                Responses MAY be accompanied by a Content-Length header field for advisory purposes.
                This allows clients to learn the full size of an entity prior to receiving all the
                data frames.  This can help in, for example, reporting progress.
              </t>
              <t>
                If a client receives a response where the sum of the data frame payload length does
                not equal the size of the Content-Length header field, the client MUST ignore the
                content length header field. <cref>Ed: See <eref
                target="https://github.com/http2/http2-spec/issues/46">issue 46</eref>.</cref>
              </t>
            </list>
          </t>

          <t>
            If a client receives a response with an absent or duplicated status header, the client
            MUST treat this as a <xref target="StreamErrorHandler">stream error</xref> of type
            PROTOCOL_ERROR.
          </t>

          <t>
            If the client receives a data frame prior to a HEADERS frame the client MUST treat this
            as a <xref target="StreamErrorHandler">stream error</xref> of type PROTOCOL_ERROR.
          </t>

          <t>
            Clients MUST support gzip compression.  Regardless of the value of the Accept-Encoding
            header field, a server MAY send responses with gzip or deflate encoding.  A compressed
            response MUST still bear an appropriate Content-Encoding header field.
          </t>
        </section>

        <section title="Authentication" anchor="Authentication">
          <t>When a client sends a request to an origin server that requires authentication, the server can reply with a "401 Unauthorized" response, and include a WWW-Authenticate challenge header that defines the authentication scheme to be used.  The client then retries the request with an Authorization header appropriate to the specified authentication scheme.</t>

          <t>There are four options for proxy authentication, Basic, Digest, NTLM and Negotiate (SPNEGO).  The first two options were defined in <xref target="RFC2617">RFC2617</xref>, and are stateless.  The second two options were developed by Microsoft and specified in <xref target="RFC4559">RFC4559</xref>, and are stateful; otherwise known as multi-round authentication, or connection authentication.</t>

          <section title="Stateless Authentication">
            <t>Stateless Authentication over SPDY is identical to how it is performed over HTTP. If multiple SPDY streams are concurrently sent to a single server, each will authenticate independently, similar to how two HTTP connections would independently authenticate to a proxy server.</t>
          </section>

          <section title="Stateful Authentication">
            <t>Unfortunately, the stateful authentication mechanisms were implemented and defined in a such a way that directly violates RFC2617 - they do not include a "realm" as part of the request.  This is problematic in SPDY because it makes it impossible for a client to disambiguate two concurrent server authentication challenges.</t>

            <t>To deal with this case, SPDY servers using Stateful Authentication MUST implement one of two changes:
              <list>
                <t>Servers can add a "realm=&lt;desired realm&gt;" header so that the two authentication requests can be disambiguated and run concurrently.  Unfortunately, given how these mechanisms work, this is probably not practical.</t>
                <t>Upon sending the first stateful challenge response, the server MUST buffer and defer all further frames which are not part of completing the challenge until the challenge has completed.  Completing the authentication challenge may take multiple round trips.  Once the client receives a "401 Authenticate" response for a stateful authentication type, it MUST stop sending new requests to the server until the authentication has completed by receiving a non-401 response on at least one stream.</t>
              </list>
            </t>
          </section>
        </section>
      </section>

      <section anchor="PushResources" title="Server Push Transactions">
        <t>
          SPDY enables a server to send multiple replies to a client for a single request.  The
          rationale for this feature is that sometimes a server knows that it will need to send
          multiple resources in response to a single request.  Without server push features, the
          client must first download the primary resource, then discover the secondary resource(s),
          and request them.
        </t>
       
        <t>
          Server push is an optional feature.  The SETTINGS_MAX_CONCURRENT_STREAMS setting from the
          client limits the number of resources that can be concurrently pushed by a server.  Server
          push can be disabled by clients that do not wish to receive pushed resources by
          advertising a SETTINGS_MAX_CONCURRENT_STREAMS <xref target="SETTINGS">SETTING</xref> of
          zero.  This prevents servers from creating the streams necessary to push resources.
        </t>

        <t>
          Clients receiving a pushed response MUST validate that the server is authorized to push
          the resource using the same-origin policy (<xref target="RFC6454" x:fmt="," x:sec="3"/>).
          For example, a SPDY connection to <spanx style="verb">example.com</spanx> is generally
          <cref>Ed: weaselly use of "generally", needs better definition</cref> not permitted to
          push a response for <spanx style="verb">www.example.org</spanx>.
        </t>

        <t>
          A client that accepts pushed resources caches those resources as though they were
          responses to GET requests.
        </t>
        <t>
          Pushing of resources avoids the round-trip delay, but also creates a potential race where
          a server can be pushing content which a client is in the process of requesting.  The
          PUSH_PROMISE frame reduces the chances of this condition occurring, while retaining the
          performance benefit.
        </t>
        <t>
           Pushed responses are associated with a request at the SPDY framing layer.  The
           PUSH_PROMISE is sent on the stream for the associated request, which allows a receiver to
           correlate the pushed resource with a request.  The pushed stream inherits all of the
           request header fields from the associated stream with the exception of resource
           identification header fields (<spanx style="verb">:host</spanx>, <spanx
           style="verb">:scheme</spanx>, and <spanx style="verb">:path</spanx>), which are provided
           as part of the PUSH_PROMISE frame.
        </t>
        <t>
          Pushed resources always have an associated <spanx style="verb">:method</spanx> of <spanx
          style="verb">GET</spanx>.  A cache MUST store these inherited and implied request header
          fields with the cached resource.
        </t>

        <section title="Server implementation">
          <t>NOTE(willchan): Resolve the MAX_CONCURRENT_STREAMS limit with HTTP2 which deletes the text in the paragraph below. This section will not be updated until we resolve that.</t>

          <t>When the server intends to push a resource to the user-agent, it promises that it will opens a new stream in the future (but not now) by sending a PUSH_PROMISE frame.  The PUSH_PROMISE frame MUST include an Associated-To-Stream-ID, Prmoised-Stream-ID, and MUST ensure that headers for ":scheme", ":host", ":path" representing the URL for the resource being pushed are either already present in the implied headers context (i.e. the request headers), or it must override the headers which do not match the pushed resource. The ":path" MUST always be different from the originally request resource.  The stream-IDs represented in the Promised-Stream-ID field MUST NOT count towards the MAX_CONCURRENT_STREAMS limit. When the server is ready to send the resource, it will send a HEADERS frame with the stream-ID indicated by the Promised-Stream-ID sent in the PUSH_PROMISE frame earlier. As with any other HEADERS frame, subsequent headers may follow in other HEADERS frames. The purpose of the association is so that the user-agent can differentiate which request induced the pushed stream; without it, if the user-agent had two tabs open to the same page, each pushing unique content under a fixed URL, the user-agent would not be able to differentiate the requests.</t>

          <t>The Associated-To-Stream-ID must be the ID of an existing, open stream.  The reason for this restriction is to have a clear endpoint for pushed content.  If the user-agent requested a resource on stream 11, the server replies on stream 11.  It can push any number of additional streams to the client before sending a FLAG_FIN on stream 11.  However, once the originating stream is closed no further push streams may be associated with it.  The pushed streams do not need to be closed (FIN set) before the originating stream is closed, they only need to be created before the originating stream closes.</t>

          <t>To prevent a race condition with the client, the server must only use the client certificate of the associated stream when pushing resources.</t>

          <t>It is illegal for a server to push a resource with the Associated-To-Stream-ID of 0, or with a Slot that is not 0.</t>

          <t>To minimize race conditions with the client, the HEADERS+PRIORITY for the pushed resources MUST be sent prior to sending any content which could allow the client to discover the pushed resource and request it.</t>

          <t>The server MUST only push resources which would have been returned from a GET request.</t>

          <t>Note:  If the server does not have all of the Name/Value Response headers available at the time it issues the HEADERS frame for the pushed resource, it may later use an additional HEADERS frame to augment the name/value pairs to be associated with the pushed stream.  The subsequent HEADERS frame(s) must not contain a header for ':host', ':scheme', or ':path' (e.g. the server can't change the identity of the resource to be pushed).  The HEADERS frame must not contain duplicate headers with a previously sent HEADERS frame.  The server must send a HEADERS frame including the scheme/host/port headers before sending any data frames on the stream.</t>
        </section>

        <section title="Client implementation">
          <t>
            When fetching a resource the client has 3 possibilities:
            <list style="numbers">
              <t>
                the resource is not being pushed
              </t>
              <t>
                the resource is being pushed, but the data has not yet arrived
              </t>
              <t>
                the resource is being pushed, and the data has started to arrive
              </t>
            </list>
          </t>

          <t>
            A client SHOULD NOT issue GET requests for a resource that has been promised.  A client
            is instead advised to wait for the pushed resource to arrive.
          </t>

          <t>
            When a client receives a PUSH_PROMISE frame from the server without the <spanx
            style="verb">:host</spanx>, <spanx style="verb">:scheme</spanx>, and <spanx
            style="verb">:path</spanx> header fields, it MUST treat this as a <xref
            target="StreamErrorHandler">stream error</xref> of type PROTOCOL_ERROR.
          </t>

          <t>
            To cancel individual server push streams, the client can issue a <xref
            target="StreamErrorHandler">stream error</xref> of type CANCEL.  After receiving a
            PUSH_PROMISE frame, the client is able to cancel the pushed resource before receiving
            any frames on the promised stream.  The server ceases transmission of the pushed
            resource; if the server has not commenced transmission, it does not start.
          </t> 

          <t>
            To cancel all server push streams related to a request, the client may issue a <xref
            target="StreamErrorHandler">stream error</xref> of type CANCEL on the
            associated-stream-id.  By cancelling that stream, the server MUST immediately stop
            sending frames for any streams with in-association-to for the original stream.
            <cref>Ed: Triggering side-effects on stream reset is going to be problematic for the
            framing layer.  Purely from a design perspective, it's a layering violation.  More
            practically speaking, the base request stream might already be removed.  Special
            handling logic would be required.</cref>
          </t>

          <t>
            A client can choose to time out pushed streams if the server does not provide the
            resource in a timely fashion.  A <xref target="StreamErrorHandler">stream error</xref>
            of type CANCEL can be used to stop a timed out push.
          </t>

          <t>
            If the server sends a HEADERS frame containing header fields that duplicate values on a
            previous HEADERS or PUSH_PROMISE frames on the same stream, the client MUST treat this
            as a <xref target="StreamErrorHandler">stream error</xref> of type PROTOCOL_ERROR.
          </t>

          <t>
            If the server sends a HEADERS frame after sending a data frame for the same stream, the
            client MAY ignore the HEADERS frame.  Ignoring the HEADERS frame after a data frame
            prevents handling of HTTP's trailing header fields (<xref target="HTTP-p1" x:fmt="of"
            x:rel="#header.trailer"/>).
          </t>
        </section>
      </section>

    </section>

    <section anchor="WebSocketLayer" title="WebSocket Layering over SPDY">
      <t>With this layering, a client and sever can share one connection for both of HTTP requests and WebSockets.</t>
      <section title="Connection Management">
        <section title="Opening Handshake">
          <section title="Handshake Request">
            <t>The client initiates an opening handshake by sending a HEADERS+PRIORITY frame. The HEADERS+PRIORITY frame MUST NOT set the FLAG_FIN because WebSocket intends to establish a bi-directional communication port and to send arbitrary data after success in opening handshake.</t>

            <t>The HEADERS+PRIORITY Name/Value section will contain all of the following headers which are associated with <xref target="RFC6455">The WebSocket protocol</xref> opening handshake. Upgrade, Connection, Sec-WebSocket-Key, and Sec-WebSocket-Version headers MUST NOT be included because we do not have to take care of protocol upgrading or verification over HTTP.</t>

            <t>The following name/value pairs MUST be present in every request:</t>
            <list>
              <t>:path - /resource name/ as used in the Client Requirements section of the WebSocket protocol specification. (See <xref target="RFC6455">RFC6455</xref>)</t>
              <t>:host - /host:port/ (e.g. www.google.com:1234) as used in the Client Requirements section of the WebSocket protocol specification. (See <xref target="RFC6455">RFC6455</xref>)</t>
              <t>:version - the WebSocket protocol version of this request. (MUST be WebSocket/8, WebSocket/13, or so. The number MUST be matched with the Sec-WebSocket-Version header. See <xref target="RFC6455">RFC6455</xref>)</t>
              <t>:scheme - the scheme portion of the URI. (MUST be ws or wss. See also /secure/ flag in <xref target="RFC6455">RFC6455</xref>)</t>
              <t>:origin - /origin/ as used in the Client Requirements section of the WebSocket protocol specification. (See <xref target="RFC6455">RFC6455</xref>)</t>
            </list>

            <t>In addition, the following OPTIONAL name/value pairs MAY be present:</t>
            <list>
              <t>:sec-websocket-protocol - the Sec-WebSocket-Protocol header (See <xref target="RFC6455">RFC6455</xref>)</t>
              <t>:sec-websocket-extensions - the Sec-WebSocket-Extensions header (See <xref target="RFC6455">RFC6455</xref>)</t>
            </list>

            <t>Also, other HTTP compatible header name/value pairs MAY be present. All header keys MUST be lowercase.</t>
          </section>
          <section title="Handshake Response">
            <t>The server responds to a client request with a HEADERS frame. If the server intends to allow the client connection, HEADERS frame MUST NOT set the FLAG_FIN and MUST have :status containing 101. But, an unsuccessful response MUST set the FLAG_FIN and MUST have :status containing non-101 code. The server MAY fail the opening handshake because of an unexpected header value or a missing mandatory header name.</t>

            <t>The client MAY send some data to the server before receiving the successful response. The server MUST ignore this data when opening handshake fails. After sending successful response, the server can send arbitrary data frames at any time.</t>

            <t>The response status line is unfolded into name/value pairs like other WebSocket headers and MUST be present:</t>
            <list>
              <t>:status - The WebSocket or fallback HTTP response status code (e.g. 101 or 101 Switching Protocols. See <xref target="RFC6455">RFC6455</xref>)</t>
            </list>

            <t>In addition, the following OPTIONAL name/value pairs MAY be present:</t>
            <list>
              <t>:sec-websocket-protocol - the Sec-WebSocket-Protocol header (See <xref target="RFC6455">RFC6455</xref>)</t>
              <t>:sec-websocket-extensions - the Sec-WebSocket-Extensions header (See <xref target="RFC6455">RFC6455</xref>)</t>
            </list>

            <t>Also, other HTTP compatible header name/value pairs MAY be present. All header names MUST be lowercase. The successful server response MUST have :status containing 101.</t>

            <t>If the handshake fails, the client MUST send a SPDY data frame with empty data field to avoid abnormal SPDY connection termination. The SPDY data frame MUST set the FLAG_FIN to indicate the client intends to send no further data on this stream.</t>
          </section>
        </section>
        <section title="Closing Handshake">
          <section title="Normal Termination">
            <t>In normal termination, WebSocket connection close frame <xref target="RFC6455">RFC6455</xref> will be sent as a SPDY data frame with FLAG_FIN set. The closing handshake is based on WebSocket protocol specification. Both of a server and a client will initiate it then the other end MUST respond it by connection close frame with FLAG_FIN set.</t>
          </section>

          <section title="Abnormal Termination and CloseEvent Handling">

            <t>In abnormal termination, RST_STREAM SHOULD be handled as connection close frame. It means that JavaScript API provides CloseEvent (See, <xref target="WEBSOCKETAPI">The WebSocket API</xref>) when a client receives RST_STREAM. Its code field SHOULD be 1006 (Abnormal Closure). The GOAWAY control frame with non-zero status code SHOULD be also handled in the same way. The status code of RST_STREAM and GOAWAY frames SHOULD be encoded to UTF-8 string with its frame type for its reason field. (e.g. SPDY/3 RST_STREAM (5) or SPDY/3 GOAWAY (1))</t>
            <t>If a server works as protocol bridge to the WebSocket protocol, it MAY send a close frame which contains the above status code and the above reason to a backend WebSocket server.</t>
          </section>
        </section>
      </section>
      <section title="Bi-directional Communication">

        <t>After the opening handshake, the client and the server can send arbitrary WebSocket control and data frames. Continuation frame, text frame, binary frame, connection close frame, ping frame, and pong frame are valid WebSocket frames. These WebSocket frames are mapped into each SPDY HEADERS frame and DATA frames as follow.</t>
        <section title="Frame mapping">

          <t>One WebSocket frame is mapped into one proceeding SPDY HEADERS frame and following plural SPDY data frames. The SPDY HEADERS frame must contain WebSocket frame fields and following SPDY data frames contain payload data. These data frames are free to be reframed.</t>
          <t>This plan doesnt care about overheads. But HEADERS frame are compressed by shared dictionary with other HEADERS+PRIORITY, HEADERS, and other PUSH_PROMISE frames in the same SPDY connection. Optimistically, it reduces framing overheads.</t>

          <t>The following name/value pairs MUST be present in SPDY HEADERS frames:</t>
          <list>
            <t>:opcode - The WebSocket frame opcode (See <xref target="RFC6455">RFC6455</xref>)</t>
            <t>:length - The WebSocket frame payload length in decimal (See <xref target="RFC6455">RFC6455</xref>)</t>
            <t>:fin - The WebSocket frame fin (See <xref target="RFC6455">RFC6455</xref>)</t>
          </list>

          <t>In addition, the following OPTIONAL name/value pairs MAY be present:</t>
          <list>
            <t>:rsv1 - The WebSocket frame rsv1</t>
            <t>:rsv2 - The WebSocket frame rsv2</t>
            <t>:rsv3 - The WebSocket frame rsv3 (See <xref target="RFC6455">RFC6455</xref>). These values must contain 0 or 1. When a key doesnt exist, the value is considered to be 0. Thus, ony enabled bits may appear here.</t>
            <t>:masking-key - The WebSocket frame masking-key (See <xref target="RFC6455">RFC6455</xref>) in hexadecimal (e.g. deadbeaf). When this key/value exist, the WebSocket frame mask (See <xref target="RFC6455">RFC6455</xref>) is considered to be 1 and following payload data MUST be masked(See <xref target="RFC6455">RFC6455</xref>), otherwise the WebSocket frame mask is considered to be 0.</t>
          </list>
        </section>
      </section>
    </section>

    <section title="Design Rationale and Notes">
      <t>Authors' notes:  The notes in this section have no bearing on the SPDY protocol as specified within this document, and none of these notes should be considered authoritative about how the protocol works.  However, these notes may prove useful in future debates about how to resolve protocol ambiguities or how to evolve the protocol going forward.  They may be removed before the final draft.</t>

      <section title="Separation of Framing Layer and Application Layer">
        <t>Readers may note that this specification sometimes blends the <xref target="FramingLayer">framing layer</xref> with requirements of a specific application - <xref target="HTTPLayer">HTTP</xref>.  This is reflected in the request/response nature of the streams, the definition of the HEADERS and compression contexts which are very similar to HTTP, and other areas as well.</t>

        <t>This blending is intentional - the primary goal of this protocol is to create a low-latency protocol for use with HTTP.  Isolating the two layers is convenient for description of the protocol and how it relates to existing HTTP implementations.  However, the ability to reuse the SPDY framing layer is a non goal.</t>
      </section>

      <section title="Error handling - Framing Layer">
        <t>Error handling at the SPDY layer splits errors into two groups:  Those that affect an individual SPDY stream, and those that do not.</t>

        <t>When an error is confined to a single stream, but general framing is in tact, SPDY attempts to use the RST_STREAM as a mechanism to invalidate the stream but move forward without aborting the connection altogether.</t>

        <t>For errors occuring outside of a single stream context, SPDY assumes the entire connection is hosed.  In this case, the endpoint detecting the error should initiate a connection close.</t>
      </section>
      <section title="One Connection Per Domain">
        <t>SPDY attempts to use fewer connections than other protocols have traditionally used.  The rationale for this behavior is because it is very difficult to provide a consistent level of service (e.g. TCP slow-start), prioritization, or optimal compression when the client is connecting to the server through multiple channels.</t>

        <t>Through lab measurements, we have seen consistent latency benefits by using fewer connections from the client.  The overall number of packets sent by SPDY can be as much as 40% less than HTTP.  Handling large numbers of concurrent connections on the server also does become a scalability problem, and SPDY reduces this load.</t>

        <t>The use of multiple connections is not without benefit, however.  Because SPDY multiplexes multiple, independent streams onto a single stream, it creates a potential for head-of-line blocking problems at the transport level.  In tests so far, the negative effects of head-of-line blocking (especially in the presence of packet loss) is outweighed by the benefits of compression and prioritization.</t>
      </section>
      <section title="Fixed vs Variable Length Fields">
        <t>SPDY favors use of fixed length 32bit fields in cases where smaller, variable length encodings could have been used.  To some, this seems like a tragic waste of bandwidth.  SPDY choses the simple encoding for speed and simplicity.</t>

        <t>The goal of SPDY is to reduce latency on the network.  The overhead of SPDY frames is generally quite low.  Each data frame is only an 8 byte overhead for a 1452 byte payload (~0.6%).  At the time of this writing, bandwidth is already plentiful, and there is a strong trend indicating that bandwidth will continue to increase.  With an average worldwide bandwidth of 1Mbps, and assuming that a variable length encoding could reduce the overhead by 50%, the latency saved by using a variable length encoding would be less than 100 nanoseconds.  More interesting are the effects when the larger encodings force a packet boundary, in which case a round-trip could be induced.  However, by addressing other aspects of SPDY and TCP interactions, we believe this is completely mitigated.</t>
      </section>
      <section title="Compression Context(s)">
        <t>When isolating the compression contexts used for communicating with multiple origins, we had a few choices to make.  We could have maintained a map (or list) of compression contexts usable for each origin.  The basic case is easy - each HEADERS frame would need to identify the context to use for that frame.  However, compression contexts are not cheap, so the lifecycle of each context would need to be bounded.  For proxy servers, where we could churn through many contexts, this would be a concern.  We considered using a static set of contexts, say 16 of them, which would bound the memory use.  We also considered dynamic contexts, which could be created on the fly, and would need to be subsequently destroyed.  All of these are complicated, and ultimately we decided that such a mechanism creates too many problems to solve.</t>

        <t>Alternatively, we've chosen the simple approach, which is to simply provide a flag for resetting the compression context.  For the common case (no proxy), this fine because most requests are to the same origin and we never need to reset the context.  For cases where we are using two different origins over a single SPDY connection, we simply reset the compression state between each transition.</t>
      </section>
      <section title="Unidirectional streams">
        <t>Besides providing a clear endpoint for unidirectional streams, Associated-To-Stream-ID also avoids the recipient of pushed streams from needing to send a set of empty frames (e.g. the HEADERS+PRIORITY w/ FLAG_FIN) to signal that it doesn't wish to send data on the stream.</t>
      </section>
      <section title="Data Compression">
        <t>Generic compression of data portion of the streams (as opposed to compression of the headers) without knowing the content of the stream is redundant.  There is no value in compressing a stream which is already compressed.  Because of this, SPDY initially allowed data compression to be optional.  We included it because study of existing websites shows that many sites are not using compression as they should, and users suffer because of it.  We wanted a mechanism where, at the SPDY layer, site administrators could simply force compression - it is better to compress twice than to not compress.</t>

        <t>Overall, however, with this feature being optional and sometimes redundant, it was unclear if it was useful at all.  We removed it from the specification.</t>
      </section>
      <section title="Server Push">
        <t>A subtle but important point is that server push streams must be declared before the associated stream is closed.  The reason for this is so that proxies have a lifetime for which they can discard information about previous streams.  If a pushed stream could associate itself with an already-closed stream, then endpoints would not have a specific lifecycle for when they could disavow knowledge of the streams which went before.</t>
      </section>
    </section>

    <section title="Security Considerations">
      <section title="Use of Same-origin constraints">
        <t>This specification uses the <xref target="RFC6454">same-origin policy</xref> in all cases where verification of content is required.</t>
      </section>

      <section title="HTTP Headers and SPDY Headers">
        <t>At the application level, HTTP uses name/value pairs in its headers.  Because SPDY merges the existing HTTP headers with SPDY headers, there is a possibility that some HTTP applications already use a particular header name.  To avoid any conflicts, all headers introduced for layering HTTP over SPDY are prefixed with ":".  ":" is not a valid sequence in HTTP header naming, preventing any possible conflict.</t>
      </section>

      <section title="Cross-Protocol Attacks">
        <t>By utilizing TLS, we believe that SPDY introduces no new cross-protocol attacks.  TLS encrypts the contents of all transmission (except the handshake itself), making it difficult for attackers to control the data which could be used in a cross-protocol attack.</t>
      </section>

      <section title="Server Push Implicit Headers">
        <t>Pushed resources do not have an associated request.  In order for existing HTTP cache control validations (such as the Vary header) to work, however, all cached resources must have a set of request headers.  For this reason, browsers MUST be careful to inherit request headers from the associated stream for the push.  This includes the 'Cookie' header.</t>
      </section>
    </section>

    <section title="Privacy Considerations">
      <section title="Long Lived Connections">
        <t>SPDY aims to keep connections open longer between clients and servers in order to reduce the latency when a user makes a request.  The maintenance of these connections over time could be used to expose private information.  For example, a user using a browser hours after the previous user stopped using that browser may be able to learn about what the previous user was doing.  This is a problem with HTTP in its current form as well, however the short lived connections make it less of a risk.</t>
      </section>

      <section title="SETTINGS frame">
        <t>The SPDY SETTINGS frame allows servers to store out-of-band transmitted information about the communication between client and server on the client.  Although this is intended only to be used to reduce latency, renegade servers could use it as a mechanism to store identifying information about the client in future requests.</t>

        <t>Clients implementing privacy modes, such as Google Chrome's "incognito mode", may wish to disable client-persisted SETTINGS storage.</t>

        <t>Clients MUST clear persisted SETTINGS information when clearing the cookies.</t>

        <t>TODO: Put range maximums on each type of setting to limit inappropriate uses.</t>
      </section>
    </section>

    <section title="Sub-protocol negotiation">
      <section title="Supporting scheme negotiation using SETTINGS frame">

        <t>By default, a client can send HEADERS+PRIORITY frames on http and https schemes, but if it want to send them on other schemes, it MUST wait for a server sending SETTINGS frame which specify declaring schemes. Thus, a server SHOULD send a SETTINGS frame as soon as possible whether it supports other schemes or not.</t>

      </section>
    </section>

    <section title="Incompatibilities with SPDY draft #3">
      <t>
        Here is a list of the major changes between this draft #3 and this draft
        <list>

          <t>DONE: Different, more precise, notation style used to describe all frames.</t>
          <t>DONE: Downsizing various fields in all messages... this will definitely need debate</t>
          <t>DONE: Removal of Version field from all messages.</t>
          <t>DONE: Reordered fields in all messages. All messages now share a common header of: length, flags, control-bit, 31-bit-payload. All control frames include an 8th byte, which is the opcode.</t>
          <t>DONE: Addition of end-of-message delimiter flag in data frames</t>
          <t>DONE: Modification of server push; addition of PUSH_PROMISE frame add a push frame, removed the 'associated-stream-id' field from SYN frame</t>

          <t>ONGOING: Significant modifications to how headers are transported. This involved changes to all frames incorporating HEADER blocks, and changes to the HEADER blocks themselves.</t>
          <t>ONGOING: Different header compression technique which uses less CPU for proxies and which should result in competitive compression</t>
          <t>TODO: Addition of end-of-header-section delimiter flag in any frame which has a header block</t>

          <t>ONGOING: Definition of cert-data push</t>
          <t>ONGOING: Definition of name-resolution push</t>
          <t>ONGOING: Redefining prioritization</t>

          <t>TODO: Modification of flow-control; allow two-levels of flow control so as to allow greater stream concurrency safely</t>
          <t>TODO: Add the 'blocked-on-flow-control' notification. Experience has shown that limits are too easy to get wrong, and this helps to self-correct this problem</t>
          <t>TODO: Modification of flow-control; headers-blocks (thus syn-stream) gets its own pool of memory, separate from data frames</t>
          <t>TODO: Everything after the first header-block-section possibly treated as flow-control</t>
          <t>TODO: Connection-error status code added for UNRECOGNIZED_SCHEME for new streams. This triggers when the recipient doesn't know how to handle a stream of that type.</t>

        </list>
      </t>
    </section>

    <section title="Requirements Notation">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </section>

    <section title="Acknowledgements">
      <t>
        Many individuals have contributed to the design and evolution of SPDY:
        Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk,
        Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth,
        Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer,
        Fan Yang, Jonathan Leighton, Alex Strom
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      &RFC1950;
      &RFC2617;
      &RFC4366;
      &RFC4559;
      &RFC6454;
      &RFC6455;

      <reference anchor="RFC0793">
        <front>
          <title abbrev='Transmission Control Protocol'>
            Transmission Control Protocol
          </title>
          <author initials='J.' surname='Postel' fullname='Jon Postel'>
            <organization>University of Southern California (USC)/Information Sciences
            Institute</organization>
          </author>
          <date year='1981' month='September' />
        </front>
        <seriesInfo name='STD' value='7' />
        <seriesInfo name='RFC' value='793' />
      </reference>

      <reference anchor="RFC2119">
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials="S." surname="Bradner" fullname="Scott Bradner">
            <organization>Harvard University</organization>
            <address><email>sob@harvard.edu</email></address>
          </author>
          <date month="March" year="1997"/>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
      </reference>

      <reference anchor="RFC3986">
        <front>
          <title abbrev='URI Generic Syntax'>Uniform Resource Identifier (URI): Generic
          Syntax</title>
          <author initials='T.' surname='Berners-Lee' fullname='Tim Berners-Lee'></author>
          <author initials='R.' surname='Fielding' fullname='Roy T. Fielding'></author>
          <author initials='L.' surname='Masinter' fullname='Larry Masinter'></author>
          <date year='2005' month='January' />
        </front>
        <seriesInfo name='STD' value='66' />
        <seriesInfo name='RFC' value='3986' />
      </reference>

      <reference anchor="RFC5246">
        <front>
          <title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
          <author initials="T." surname="Dierks" fullname="Tim Dierks"/>
          <author initials="E." surname="Rescorla" fullname="Eric Rescorla"/>
          <date year="2008" month="August" />
        </front>
        <seriesInfo name="RFC" value="5246" />
      </reference>

      <reference anchor="RFC6454">
        <front>
          <title>The Web Origin Concept</title>
          <author initials='A.' surname='Barth' fullname='A. Barth'/>
          <date year='2011' month='December' />
        </front>
        <seriesInfo name='RFC' value='6454' />
      </reference>

      <reference anchor="TLSNPN" target="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-01">
        <front>
          <title>TLS Next Protocol Negotiation</title>
          <author initials="A." surname="Langley"> <organization/> </author>
        </front>
      </reference>
      <reference anchor='HTTP-p1'>
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
          <author initials='R.' surname='Fielding' fullname='Roy Fielding'></author>
          <author initials='J.' surname='Reschke' fullname='Julian Reschke'></author>
          <date month='February' year='2013' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-p1-messaging-22' />
        <x:source href="refs/draft-ietf-httpbis-p1-messaging-22.xml" basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p1-messaging"/>
      </reference>
      <reference anchor='HTTP-p2'>
        <front>
          <title>
          Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
          <author initials='R.' surname='Fielding' fullname='Roy Fielding'></author>
          <author initials='J.' surname='Reschke' fullname='Julian Reschke'></author>
          <date month='February' year='2013' />
        </front>
        <seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-p2-semantics-22' />
        <x:source href="refs/draft-ietf-httpbis-p2-semantics-22.xml" basename="https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/22/p2-semantics"/>
      </reference>
      <reference anchor="HTTP-p4">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
          <author fullname="Roy T. Fielding" initials="R." role="editor" surname="Fielding">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author fullname="Julian F. Reschke" initials="J. F." role="editor" surname="Reschke">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month='February' year='2013' />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p4-conditional-22" />
      </reference>
      <reference anchor="HTTP-p5">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="Y." surname="Lafon" fullname="Yves Lafon" role="editor">
            <organization abbrev="W3C">World Wide Web Consortium</organization>
            <address><email>ylafon@w3.org</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month='February' year='2013' />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p5-range-22"/>
      </reference>
      <reference anchor="HTTP-p6">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="M." surname="Nottingham" fullname="Mark Nottingham" role="editor">
            <organization>Akamai</organization>
            <address><email>mnot@mnot.net</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month='February' year='2013' />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p6-cache-22"/>
      </reference>
      <reference anchor="HTTP-p7">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
          <author initials="R." surname="Fielding" fullname="Roy T. Fielding" role="editor">
            <organization abbrev="Adobe">Adobe Systems Incorporated</organization>
            <address><email>fielding@gbiv.com</email></address>
          </author>
          <author initials="J. F." surname="Reschke" fullname="Julian F. Reschke" role="editor">
            <organization abbrev="greenbytes">greenbytes GmbH</organization>
            <address><email>julian.reschke@greenbytes.de</email></address>
          </author>
          <date month='February' year='2013' />
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-p7-auth-22"/>
      </reference>
      <reference anchor="ASCII">
        <front>
          <title>US-ASCII. Coded Character Set - 7-Bit American Standard Code for Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.</title>
        </front>
      </reference>
      <reference anchor="UDELCOMPRESSION" target="http://www.eecis.udel.edu/~amer/PEL/poc/pdf/SPDY-Fan.pdf">
        <front>
          <title>A Methodology to Derive SPDYs Initial Dictionary for Zlib Compression</title>
          <author initials="F." surname="Yang"></author>
          <author initials="P." surname="Amer"></author>
          <author initials="J." surname="Leighton"></author>
        </front>
      </reference>
      <reference anchor="WEBSOCKETAPI" target="http://www.w3.org/TR/websockets/">
        <front>
          <title>The WebSocket API</title>
          <author initials="I." surname="Hickson"> <organization/> </author>
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="TALKING" target="http://w2spconf.com/2011/papers/websocket.pdf">
        <front>
          <title>
            Talking to Yourself for Fun and Profit
          </title>
          <author initials="L-S." surname="Huang"/>
          <author initials="E." surname="Chen"/>
          <author initials="A." surname="Barth"/>
          <author initials="E." surname="Rescorla"/>
          <author initials="C." surname="Jackson"/>
          <date year="2011" />
        </front>
      </reference>
    </references>

    <section title="Changes">
      <t>To be removed by RFC Editor before publication</t>
    </section>
  </back>
</rfc>

